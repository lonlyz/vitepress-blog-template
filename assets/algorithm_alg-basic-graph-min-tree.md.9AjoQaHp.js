import{_ as e,c as r,ai as l,o as i}from"./chunks/framework.BrYByd3F.js";const t="/vitepress-blog-template/images/alg/alg-graph-min-tree-0.png",o="/vitepress-blog-template/images/alg/alg-graph-min-tree-1.png",s="/vitepress-blog-template/images/alg/alg-graph-min-tree-2.png",_=JSON.parse('{"title":"图 - 最小生成树(Prim & Kruskal)","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/alg-basic-graph-min-tree.md","filePath":"algorithm/alg-basic-graph-min-tree.md","lastUpdated":1737706346000}'),n={name:"algorithm/alg-basic-graph-min-tree.md"};function p(h,a,c,m,u,d){return i(),r("div",null,a[0]||(a[0]=[l('<h1 id="图-最小生成树-prim-kruskal" tabindex="-1">图 - 最小生成树(Prim &amp; Kruskal) <a class="header-anchor" href="#图-最小生成树-prim-kruskal" aria-label="Permalink to &quot;图 - 最小生成树(Prim &amp; Kruskal)&quot;">​</a></h1><blockquote><p>Kruskal算法是从最小权重边着手，将森林里的树逐渐合并；prim算法是从顶点出发，在根结点的基础上建起一棵树。@pdai</p></blockquote><h2 id="最小生成树相关名词" tabindex="-1">最小生成树相关名词 <a class="header-anchor" href="#最小生成树相关名词" aria-label="Permalink to &quot;最小生成树相关名词&quot;">​</a></h2><ul><li><code>连通图</code>: 在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。</li><li><code>强连通图</code>: 在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。</li><li><code>连通网</code>: 在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</li><li><code>生成树</code>: 一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</li><li><code>最小生成树</code>: 在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</li></ul><p><img src="'+t+'" alt="error.图片加载失败"></p><h2 id="最小生成树算法" tabindex="-1">最小生成树算法 <a class="header-anchor" href="#最小生成树算法" aria-label="Permalink to &quot;最小生成树算法&quot;">​</a></h2><h3 id="kruskal算法" tabindex="-1">Kruskal算法 <a class="header-anchor" href="#kruskal算法" aria-label="Permalink to &quot;Kruskal算法&quot;">​</a></h3><p>此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</p><ol><li>把图中的所有边按代价从小到大排序；</li><li>把图中的n个顶点看成独立的n棵树组成的森林；</li><li>按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。</li><li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li></ol><p><img src="'+o+'" alt="error.图片加载失败"></p><h3 id="prim算法" tabindex="-1">Prim算法 <a class="header-anchor" href="#prim算法" aria-label="Permalink to &quot;Prim算法&quot;">​</a></h3><p>此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p><ul><li>图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;</li><li>在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。</li><li>重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</li></ul><p>由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息，:</p><p><img src="'+s+'" alt="error.图片加载失败"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>因为Kruskal涉及大量对边的操作，所以它适用于稀疏图；普通的prim算法适用于稠密图，但堆优化的prim算法更适用于稀疏图，因为其时间复杂度是由边的数量决定的。</p><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><ul><li><p><a href="https://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noreferrer">https://blog.csdn.net/luoshixian099/article/details/51908175</a></p></li><li><p><a href="https://www.cnblogs.com/wuxiangnong/p/10885129.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/wuxiangnong/p/10885129.html</a></p></li></ul><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',20)]))}const b=e(n,[["render",p]]);export{_ as __pageData,b as default};
