import{_ as a,c as l,ai as t,o as r}from"./chunks/framework.BrYByd3F.js";const u=JSON.parse('{"title":"树 - 红黑树(R-B Tree)","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/alg-basic-tree-redblack.md","filePath":"algorithm/alg-basic-tree-redblack.md","lastUpdated":1737706346000}'),i={name:"algorithm/alg-basic-tree-redblack.md"};function o(p,e,n,c,s,h){return r(),l("div",null,e[0]||(e[0]=[t('<h1 id="树-红黑树-r-b-tree" tabindex="-1">树 - 红黑树(R-B Tree) <a class="header-anchor" href="#树-红黑树-r-b-tree" aria-label="Permalink to &quot;树 - 红黑树(R-B Tree)&quot;">​</a></h1><blockquote><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组，是平衡二叉树和AVL树的折中。@pdai</p></blockquote><p>提示</p><p>红黑树的讲解在<a href="https://pdai.tech/md/java/collection/java-map-TreeMap&amp;TreeSet.html" target="_blank" rel="noreferrer">JDK TreeMap&amp;TreeSet源码解读</a>中有详细的展示 。这里再补充一些其它内容。</p><h2 id="为什么要有红黑树" tabindex="-1">为什么要有红黑树 <a class="header-anchor" href="#为什么要有红黑树" aria-label="Permalink to &quot;为什么要有红黑树&quot;">​</a></h2><p>我们在上一篇博客认识到了平衡二叉树(AVLTree)，了解到AVL树的性质，其实平衡二叉树最大的作用就是查找,AVL树的查找、插入和删除在平均和最坏情况下都是O(logn)。AVL树的效率就是高在这个地方。如果在AVL树中插入或删除节点后，使得高度之差大于1。此时，AVL树的平衡状态就被破坏，它就不再是一棵二叉树；为了让它重新维持在一个平衡状态，就需要对其进行旋转处理, 那么创建一颗平衡二叉树的成本其实不小. 这个时候就有人开始思考，并且提出了红黑树的理论，那么红黑树到底比AVL树好在哪里?</p><p>红黑树与AVL树的比较:</p><ul><li>1.AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，cpu太快，可以忽略性能差异</li><li>2.红黑树的插入删除比AVL树更便于控制操作</li><li>3.红黑树整体性能略优于AVL树(红黑树旋转情况少于AVL树)</li></ul><blockquote><p><code>红黑树的性质</code>: 红黑树是一棵二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡。</p></blockquote><p>具体性质如下:</p><ul><li>每个节点颜色不是黑色，就是红色</li><li>根节点是黑色的</li><li>如果一个节点是红色，那么它的两个子节点就是黑色的(没有连续的红节点)</li><li>对于每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点</li></ul><h2 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h2><ul><li>Java ConcurrentHashMap &amp; TreeMap</li><li>C++ STL: map &amp; set</li><li>linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块</li><li>epoll在内核中的实现，用红黑树管理事件块</li><li>nginx中，用红黑树管理timer等</li></ul><h2 id="其它参考" tabindex="-1">其它参考 <a class="header-anchor" href="#其它参考" aria-label="Permalink to &quot;其它参考&quot;">​</a></h2><ul><li><p>@skywang12345写的红黑树实现 <a href="https://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/skywang12345/p/3245399.html</a></p></li><li><p>30张图带你彻底理解红黑树 <a href="https://www.cnblogs.com/kumufengchun/p/11169138.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/kumufengchun/p/11169138.html</a></p></li><li><p>浅析红黑树(RBTree)原理及实现 <a href="https://blog.csdn.net/tanrui519521/article/details/80980135" target="_blank" rel="noreferrer">https://blog.csdn.net/tanrui519521/article/details/80980135</a></p></li></ul><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',16)]))}const m=a(i,[["render",o]]);export{u as __pageData,m as default};
