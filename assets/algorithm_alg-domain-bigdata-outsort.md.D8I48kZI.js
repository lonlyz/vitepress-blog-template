import{_ as t,c as l,ai as e,o as n}from"./chunks/framework.BrYByd3F.js";const i="/vitepress-blog-template/images/alg/alg-bigdata-out-sort-0.png",s="/vitepress-blog-template/images/alg/alg-bigdata-out-sort-1.png",m=JSON.parse('{"title":"大数据处理 - 外（磁盘文件）排序","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/alg-domain-bigdata-outsort.md","filePath":"algorithm/alg-domain-bigdata-outsort.md","lastUpdated":1737706346000}'),r={name:"algorithm/alg-domain-bigdata-outsort.md"};function o(p,a,d,h,c,g){return n(),l("div",null,a[0]||(a[0]=[e(`<h1 id="大数据处理-外-磁盘文件-排序" tabindex="-1">大数据处理 - 外（磁盘文件）排序 <a class="header-anchor" href="#大数据处理-外-磁盘文件-排序" aria-label="Permalink to &quot;大数据处理 - 外（磁盘文件）排序&quot;">​</a></h1><blockquote><p>在编程珠玑中，描述了三种外部磁盘文件排序的解决方法，分别是</p></blockquote><ul><li><a href="https://pdai.tech/md/algorithm/alg-domain-bigdata-outsort.html#%E5%A4%96%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D" target="_blank" rel="noreferrer">外排序介绍</a></li><li><a href="https://pdai.tech/md/algorithm/alg-domain-bigdata-outsort.html#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5%E5%92%8C%E6%96%B9%E6%A1%88" target="_blank" rel="noreferrer">相关问题引入和方案</a><ul><li><a href="https://pdai.tech/md/algorithm/alg-domain-bigdata-outsort.html#%E4%BD%8D%E5%9B%BE%E6%8E%92%E5%BA%8F%E6%B3%95" target="_blank" rel="noreferrer">位图排序法</a></li><li><a href="https://pdai.tech/md/algorithm/alg-domain-bigdata-outsort.html#%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noreferrer">多路归并排序</a></li></ul></li><li><a href="https://pdai.tech/md/algorithm/alg-domain-bigdata-outsort.html#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0" target="_blank" rel="noreferrer">参考文章</a></li></ul><h2 id="外排序介绍" tabindex="-1">外排序介绍 <a class="header-anchor" href="#外排序介绍" aria-label="Permalink to &quot;外排序介绍&quot;">​</a></h2><blockquote><p>外排序, 即借助外部存储进行排序.</p></blockquote><ul><li><code>适用范围</code>: 大数据的排序，去重</li><li><code>基本原理及要点</code>: 外排序的归并方法，置换选择败者树原理，最优归并树</li></ul><h2 id="相关问题引入和方案" tabindex="-1">相关问题引入和方案 <a class="header-anchor" href="#相关问题引入和方案" aria-label="Permalink to &quot;相关问题引入和方案&quot;">​</a></h2><p>问题描述如下：</p><ul><li><strong>输入</strong>：一个最多含有n个不重复的正整数（也就是说可能含有少于n个不重复正整数）的文件，其中每个数都小于等于n，且n=10^7（1000万个）。</li><li><strong>输出</strong>：得到按从小到大升序排列的包含所有输入的整数的列表。</li><li><strong>条件</strong>：最多有大约1MB的内存空间可用，但磁盘空间足够。且要求运行时间在5分钟以下，10秒为最佳结果。</li></ul><p>在编程珠玑中，描述了三种解决方法，分别是</p><ul><li><strong>位图排序法</strong> - 在待排序文件中不含重复数的情况下，位图排序法是最高效的</li><li><strong>外排多路归并法</strong> - 在更一般的情况下，外排多路归并法具有通用性</li><li><strong>多通道排序法</strong></li></ul><p>所以本文主要介绍前两种。</p><h3 id="位图排序法" tabindex="-1">位图排序法 <a class="header-anchor" href="#位图排序法" aria-label="Permalink to &quot;位图排序法&quot;">​</a></h3><p>熟悉位图的朋友可能会想到用位图来表示这个文件集合。例如正如编程珠玑一书上所述，用一个20位长的字符串来表示一个所有元素都小于20的简单的非负整数集合，边框用如下字符串来表示集合<code>{1,2,3,5,8,13}</code>：<code>0 1 1 1 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0</code>；上述集合中各数对应的位置则置1，没有对应的数的位置则置0。</p><blockquote><p>参考编程珠玑一书上的位图方案，针对我们的10^7个数据量的磁盘文件排序问题，我们可以这么考虑，由于每个7位十进制整数表示一个小于1000万的整数。我们可以使用一个具有1000万个位的字符串来表示这个文件，其中，当且仅当整数i在文件中存在时，第i位为1。采取这个位图的方案是因为我们面对的这个问题的特殊性：</p><ul><li>1、输入数据限制在相对较小的范围内</li><li>2、数据没有重复，</li><li>3、其中的每条记录都是单一的整数，没有任何其它与之关联的数据。</li></ul></blockquote><p>所以，此问题用位图的方案分为以下三步进行解决：</p><ul><li>第一步，将所有的位都置为0，从而将集合初始化为空。</li><li>第二步，通过读入文件中的每个整数来建立集合，将每个对应的位都置为1。</li><li>第三步，检验每一位，如果该位为1，就输出对应的整数。</li></ul><p>经过以上三步后，产生有序的输出文件。令n为位图向量中的位数（本例中为1000 0000），程序可以用伪代码表示如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//磁盘文件排序位图方案的伪代码</span></span>
<span class="line"><span>//copyright@ Jon Bentley</span></span>
<span class="line"><span>//July、updated，2011.05.29。</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>//第一步，将所有的位都初始化为0</span></span>
<span class="line"><span>for i ={0,....n}    </span></span>
<span class="line"><span>   bit[i]=0;</span></span>
<span class="line"><span>//第二步，通过读入文件中的每个整数来建立集合，将每个对应的位都置为1。</span></span>
<span class="line"><span>for each i in the input file   </span></span>
<span class="line"><span>   bit[i]=1;</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>//第三步，检验每一位，如果该位为1，就输出对应的整数。</span></span>
<span class="line"><span>for i={0...n}    </span></span>
<span class="line"><span>  if bit[i]==1      </span></span>
<span class="line"><span>    write i on the output file</span></span></code></pre></div><p>上述的位图方案，共需要扫描输入数据两次，具体执行步骤如下：</p><ul><li>第一次，只处理1—4999999之间的数据，这些数都是小于5000000的，对这些数进行位图排序，只需要约5000000/8=625000Byte，也就是0.625M，排序后输出。</li><li>第二次，扫描输入文件时，只处理4999999-10000000的数据项，也只需要0.625M（可以使用第一次处理申请的内存）。</li></ul><p>因此，总共也只需要0.625M</p><blockquote><p>位图的的方法有必要强调一下，就是位图的适用范围为<strong>针对不重复的数据进行排序</strong>，若数据有重复，位图方案就不适用了。</p></blockquote><h3 id="多路归并排序" tabindex="-1">多路归并排序 <a class="header-anchor" href="#多路归并排序" aria-label="Permalink to &quot;多路归并排序&quot;">​</a></h3><blockquote><p>首先我们需要回顾下，什么是归并排序，请参考：<a href="https://pdai.tech/md/algorithm/alg-sort-x-merge.html" target="_blank" rel="noreferrer">排序 - 归并排序(Merge Sort)</a></p></blockquote><p><strong>相对于多路归并排序，归并排序的本质是二路归并排序</strong>；我们已经知道，当数据量大到不适合在内存中排序时，可以利用多路归并算法对磁盘文件进行排序。</p><p>我们以一个包含很多个整数的大文件为例，来说明多路归并的外排序算法基本思想。假设文件中整数个数为N(N是亿级的)，整数之间用空格分开。首先分多次从该文件中读取M（十万级）个整数，每次将M个整数在内存中使用内部排序之后存入临时文件，这样就得到多个外部文件，对应于多个外部文件，我们可以利用多路归并将各个临时文件中的数据一边读入内存，一边进行归并输出到输出文件。显然，该排序算法需要对每个整数做2次磁盘读和2次磁盘写。（如果根据初始外部文件的个数设置归并的路数，则会对每个整数做多次读/写，具体次数可参考严蔚敏书籍）</p><p><img src="`+i+'" alt="error.图片加载失败"><img src="'+s+'" alt="error.图片加载失败"></p><p>我们来编程实现上述磁盘文件排序的问题，代码思路对应上面图由两部分构成：</p><ul><li><p><strong>内存排序</strong></p><ul><li>由于要求的可用内存为1MB，那么每次可以在内存中对250K的数据进行排序，然后将有序的数写入硬盘。</li><li>那么10M的数据需要循环40次，最终产生40个有序的文件。</li></ul></li><li><p><strong>归并排序</strong></p><ul><li>将每个文件最开始的数读入(由于有序，所以为该文件最小数)，存放在一个大小为40的first_data数组中；</li><li>选择first_data数组中最小的数min_data，及其对应的文件索引index；</li><li>将first_data数组中最小的数写入文件result，然后更新数组first_data(根据index读取该文件下一个数代替min_data)；</li><li>判断是否所有数据都读取完毕，否则返回2。</li></ul></li></ul><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><p>其中涉及的算法和具体的实现，请参看如下文章：</p><ul><li><a href="https://blog.csdn.net/v%5C_JULY%5C_v/article/details/7382693" target="_blank" rel="noreferrer">https://blog.csdn.net/v\\_JULY\\_v/article/details/7382693</a></li><li><a href="https://www.cnblogs.com/harryshayne/archive/2011/07/02/2096196.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/harryshayne/archive/2011/07/02/2096196.html</a></li></ul><p>再次推荐下CSDN博主July，博客专注面试、算法、机器学习。</p><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',35)]))}const b=t(r,[["render",o]]);export{m as __pageData,b as default};
