import{_ as t,c as e,ai as n,o as l}from"./chunks/framework.BrYByd3F.js";const s="/vitepress-blog-template/images/alg/alg-domain-char-bf-2.png",i="/vitepress-blog-template/images/alg/alg-domain-char-bf-1.png",u=JSON.parse('{"title":"字符串匹配 - 模式预处理：朴素算法（Naive)(暴力破解)","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/alg-domain-char-match-bf.md","filePath":"algorithm/alg-domain-char-match-bf.md","lastUpdated":1737706346000}'),r={name:"algorithm/alg-domain-char-match-bf.md"};function o(p,a,c,h,m,d){return l(),e("div",null,a[0]||(a[0]=[n(`<h1 id="字符串匹配-模式预处理-朴素算法-naive-暴力破解" tabindex="-1">字符串匹配 - 模式预处理：朴素算法（Naive)(暴力破解) <a class="header-anchor" href="#字符串匹配-模式预处理-朴素算法-naive-暴力破解" aria-label="Permalink to &quot;字符串匹配 - 模式预处理：朴素算法（Naive)(暴力破解)&quot;">​</a></h1><blockquote><p>朴素的字符串匹配算法又称为<strong>暴力匹配算法</strong>（Brute Force Algorithm），最为简单的字符串匹配算法。 @pdai</p></blockquote><h2 id="算法简介" tabindex="-1">算法简介 <a class="header-anchor" href="#算法简介" aria-label="Permalink to &quot;算法简介&quot;">​</a></h2><blockquote><p>朴素的字符串匹配算法又称为暴力匹配算法（Brute Force Algorithm），它的主要特点是：</p></blockquote><ul><li>没有预处理阶段；</li><li>滑动窗口总是后移 1 位；</li><li>对模式中的字符的比较顺序不限定，可以从前到后，也可以从后到前；</li><li>匹配阶段需要 O((n - m + 1)m) 的时间复杂度；</li><li>需要 2n 次的字符比较；</li></ul><p>很显然，朴素的字符串匹配算法 NAIVE-STRING-MATCHER 是最原始的算法，它通过使用循环来检查是否在范围 n-m+1 中存在满足条件 P[1..m] = T [s + 1..s + m] 的有效位移 s。</p><p>伪代码如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>NAIVE-STRING-MATCHER(T, P)</span></span>
<span class="line"><span>  n ← length[T]</span></span>
<span class="line"><span>  m ← length[P]</span></span>
<span class="line"><span>  for s ← 0 to n - m</span></span>
<span class="line"><span>    do if P[1 .. m] = T[s + 1 .. s + m]</span></span>
<span class="line"><span>      then print &quot;Pattern occurs with shift&quot; s</span></span></code></pre></div><p><img src="`+s+'" alt="error.图片加载失败"></p><p>如上图中，对于模式 P = aab 和文本 T = acaabc，将模式 P 沿着 T 从左到右滑动，逐个比较字符以判断模式 P 在文本 T 中是否存在。</p><p>可以看出，NAIVE-STRING-MATCHER 没有对模式 P 进行预处理，所以预处理的时间为 0。而匹配的时间在最坏情况下为 Θ((n-m+1)m)，如果 m = [n/2]，则为 Θ(n2)。</p><h2 id="图例分析" tabindex="-1">图例分析 <a class="header-anchor" href="#图例分析" aria-label="Permalink to &quot;图例分析&quot;">​</a></h2><p>假设有两个字符串：</p><ul><li>M=&quot;abcdefabcdx&quot;;</li><li>T=&quot;abcdx&quot;;</li></ul><p>想要找到T串在M串中的位置，要怎么找呢？</p><p><img src="'+i+'" alt="error.图片加载失败"></p><p>也就是说，从主串M的第一个字符开始分别与子串从开头进行比较，当发现不匹配时，主串回到这一轮开始的下一个字符，子串从头开始比较。直到子串所有的字符都匹配，返回所在主串中的下标。</p><h2 id="算法复杂度" tabindex="-1">算法复杂度 <a class="header-anchor" href="#算法复杂度" aria-label="Permalink to &quot;算法复杂度&quot;">​</a></h2><p>假设S的长度是m，T的长度是n，暂不考虑pos，从字符串S的开头开始比较。</p><ul><li>最好的情况是第一次就匹配了，需要比较的次数是n.</li><li>最坏的情况下，就是上面举的这种例子，需要把整个字符串都比较完，从下面的代码中就体现为把两层循环都跑了一遍。这时候，比较的次数就是t*(s-t+1).</li></ul><p>所以这个算法的(最坏)时间复杂度就是o(t(s-t+1))，近似为o(n2).</p><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><ul><li><a href="https://www.cnblogs.com/gaochundong/p/string%5C_matching.html#kmp%5C_string%5C_matching%5C_algorithm" target="_blank" rel="noreferrer">https://www.cnblogs.com/gaochundong/p/string\\_matching.html#kmp\\_string\\_matching\\_algorithm</a></li><li><a href="https://blog.csdn.net/u013301192/article/details/48507695" target="_blank" rel="noreferrer">https://blog.csdn.net/u013301192/article/details/48507695</a></li></ul><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',24)]))}const b=t(r,[["render",o]]);export{u as __pageData,b as default};
