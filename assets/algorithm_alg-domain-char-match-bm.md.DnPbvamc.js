import{_ as t,c as r,ai as e,o as a}from"./chunks/framework.BrYByd3F.js";const u="/vitepress-blog-template/images/alg/alg-domain-char-0.png",q="/vitepress-blog-template/images/alg/alg-domain-char-2.png",p="/vitepress-blog-template/images/alg/alg-domain-char-3.png",l="/vitepress-blog-template/images/alg/alg-domain-char-4.png",i="/vitepress-blog-template/images/alg/alg-domain-char-5.png",s="/vitepress-blog-template/images/alg/alg-domain-char-6.png",g="/vitepress-blog-template/images/alg/alg-domain-char-7.png",m="/vitepress-blog-template/images/alg/alg-domain-char-8.png",c="/vitepress-blog-template/images/alg/alg-domain-char-9.png",n="/vitepress-blog-template/images/alg/alg-domain-char-10.png",h="/vitepress-blog-template/images/alg/alg-domain-char-11.png",_="/vitepress-blog-template/images/alg/alg-domain-char-12.png",d="/vitepress-blog-template/images/alg/alg-domain-char-13.png",b="/vitepress-blog-template/images/alg/alg-domain-char-14.png",k=JSON.parse('{"title":"字符串匹配 - 模式预处理：BM 算法 (Boyer-Moore)","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/alg-domain-char-match-bm.md","filePath":"algorithm/alg-domain-char-match-bm.md","lastUpdated":1737706346000}'),P={name:"algorithm/alg-domain-char-match-bm.md"};function E(B,o,f,M,A,y){return a(),r("div",null,o[0]||(o[0]=[e('<h1 id="字符串匹配-模式预处理-bm-算法-boyer-moore" tabindex="-1">字符串匹配 - 模式预处理：BM 算法 (Boyer-Moore) <a class="header-anchor" href="#字符串匹配-模式预处理-bm-算法-boyer-moore" aria-label="Permalink to &quot;字符串匹配 - 模式预处理：BM 算法 (Boyer-Moore)&quot;">​</a></h1><blockquote><p>各种文本编辑器的&quot;查找&quot;功能（Ctrl+F），大多采用Boyer-Moore算法，效率非常高。</p></blockquote><h2 id="算法简介" tabindex="-1">算法简介 <a class="header-anchor" href="#算法简介" aria-label="Permalink to &quot;算法简介&quot;">​</a></h2><blockquote><p>在 1977 年，Robert S. Boyer (Stanford Research Institute) 和 J Strother Moore (Xerox Palo Alto Research Center) 共同发表了文章《A Fast String Searching Algorithm》，介绍了一种新的快速字符串匹配算法。这种算法在逻辑上相对于现有的算法有了显著的改进，它对要搜索的字符串进行倒序的字符比较，并且当字符比较不匹配时无需对整个模式串再进行搜索。</p></blockquote><p>Boyer-Moore 算法的主要特点有：</p><ul><li>对模式字符的比较顺序时从右向左；</li><li>预处理需要 O(m + σ) 的时间和空间复杂度；</li><li>匹配阶段需要 O(m × n) 的时间复杂度；</li><li>匹配阶段在最坏情况下需要 3n 次字符比较；</li><li>最优复杂度 O(n/m)；</li></ul><p>在 Naive 算法中，对文本 T 和模式 P 字符串均未做预处理。而在 KMP 算法中则对模式 P 字符串进行了预处理操作，以预先计算模式串中各位置的最长相同前后缀长度的数组。Boyer–Moore 算法同样也是对模式 P 字符串进行预处理。</p><p>我们知道，在 Naive 算法中，如果发现模式 P 中的字符与文本 T 中的字符不匹配时，需要将文本 T 的比较位置向后滑动一位，模式 P 的比较位置归 0 并从头开始比较。而 KMP 算法则是根据预处理的结果进行判断以使模式 P 的比较位置可以向后滑动多个位置。Boyer–Moore 算法的预处理过程也是为了达到相同效果。</p><p>Boyer–Moore 算法在对模式 P 字符串进行预处理时，将采用两种不同的启发式方法。这两种启发式的预处理方法称为：</p><ul><li><code>坏字符（Bad Character Heuristic）</code>：当文本 T 中的某个字符跟模式 P 的某个字符不匹配时，我们称文本 T 中的这个失配字符为坏字符。</li><li><code>好后缀（Good Suffix Heuristic）</code>：当文本 T 中的某个字符跟模式 P 的某个字符不匹配时，我们称文本 T 中的已经匹配的字符串为好后缀。</li></ul><p>Boyer–Moore 算法在预处理时，将为两种不同的启发法结果创建不同的数组，分别称为 <code>Bad-Character-Shift（or The Occurrence Shift）</code>和 <code>Good-Suffix-Shift（or Matching Shift）</code>。当进行字符匹配时，如果发现模式 P 中的字符与文本 T 中的字符不匹配时，将比较两种不同启发法所建议的移动位移长度，选择最大的一个值来对模式 P 的比较位置进行滑动。</p><p>此外，Naive 算法和 KMP 算法对模式 P 的比较方向是从前向后比较，而 Boyer–Moore 算法的设计则是从后向前比较，即从尾部向头部方向进行比较。</p><h2 id="图例分析" tabindex="-1">图例分析 <a class="header-anchor" href="#图例分析" aria-label="Permalink to &quot;图例分析&quot;">​</a></h2><blockquote><p>例子来源于阮一峰的 <a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" target="_blank" rel="noreferrer">字符串匹配的Boyer-Moore算法在新窗口打开</a></p></blockquote><p>下面，我根据Moore教授自己的例子来解释这种算法。</p><p><img src="'+u+'" alt="error.图片加载失败"></p><p>假定字符串为&quot;HERE IS A SIMPLE EXAMPLE&quot;，搜索词为&quot;EXAMPLE&quot;。</p><p><img src="'+q+'" alt="error.图片加载失败"></p><p>首先，&quot;字符串&quot;与&quot;搜索词&quot;头部对齐，从尾部开始比较。</p><p>这是一个很聪明的想法，因为如果尾部字符不匹配，那么只要一次比较，就可以知道前7个字符（整体上）肯定不是要找的结果。</p><p>我们看到，&quot;S&quot;与&quot;E&quot;不匹配。这时，&quot;S&quot;就被称为&quot;坏字符&quot;（bad character），即不匹配的字符。我们还发现，&quot;S&quot;不包含在搜索词&quot;EXAMPLE&quot;之中，这意味着可以把搜索词直接移到&quot;S&quot;的后一位。</p><p><img src="'+p+'" alt="error.图片加载失败"></p><p>依然从尾部开始比较，发现&quot;P&quot;与&quot;E&quot;不匹配，所以&quot;P&quot;是&quot;坏字符&quot;。但是，&quot;P&quot;包含在搜索词&quot;EXAMPLE&quot;之中。所以，将搜索词后移两位，两个&quot;P&quot;对齐。</p><p><img src="'+l+'" alt="error.图片加载失败"></p><p>我们由此总结出&quot;坏字符规则&quot;：</p><blockquote><p>后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置</p></blockquote><p>如果&quot;坏字符&quot;不包含在搜索词之中，则上一次出现位置为 -1。</p><p>以&quot;P&quot;为例，它作为&quot;坏字符&quot;，出现在搜索词的第6位（从0开始编号），在搜索词中的上一次出现位置为4，所以后移 6 - 4 = 2位。再以前面第二步的&quot;S&quot;为例，它出现在第6位，上一次出现位置是 -1（即未出现），则整个搜索词后移 6 - (-1) = 7位。</p><p><img src="'+i+'" alt="error.图片加载失败"></p><p>依然从尾部开始比较，&quot;E&quot;与&quot;E&quot;匹配。</p><p><img src="'+s+'" alt="error.图片加载失败"></p><p>比较前面一位，&quot;LE&quot;与&quot;LE&quot;匹配。</p><p><img src="'+g+'" alt="error.图片加载失败"></p><p>比较前面一位，&quot;PLE&quot;与&quot;PLE&quot;匹配。</p><p><img src="'+m+'" alt="error.图片加载失败"></p><p>比较前面一位，&quot;MPLE&quot;与&quot;MPLE&quot;匹配。我们把这种情况称为&quot;好后缀&quot;（good suffix），即所有尾部匹配的字符串。注意，&quot;MPLE&quot;、&quot;PLE&quot;、&quot;LE&quot;、&quot;E&quot;都是好后缀。</p><p><img src="'+c+'" alt="error.图片加载失败"></p><p>比较前一位，发现&quot;I&quot;与&quot;A&quot;不匹配。所以，&quot;I&quot;是&quot;坏字符&quot;。</p><p><img src="'+n+'" alt="error.图片加载失败"></p><p>根据&quot;坏字符规则&quot;，此时搜索词应该后移 2 - （-1）= 3 位。问题是，此时有没有更好的移法？</p><p><img src="'+h+'" alt="error.图片加载失败"></p><p>我们知道，此时存在&quot;好后缀&quot;。所以，可以采用&quot;好后缀规则&quot;：</p><blockquote><p>后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置</p></blockquote><p>举例来说，如果字符串&quot;ABCDAB&quot;的后一个&quot;AB&quot;是&quot;好后缀&quot;。那么它的位置是5（从0开始计算，取最后的&quot;B&quot;的值），在&quot;搜索词中的上一次出现位置&quot;是1（第一个&quot;B&quot;的位置），所以后移 5 - 1 = 4位，前一个&quot;AB&quot;移到后一个&quot;AB&quot;的位置。</p><p>再举一个例子，如果字符串&quot;ABCDEF&quot;的&quot;EF&quot;是好后缀，则&quot;EF&quot;的位置是5 ，上一次出现的位置是 -1（即未出现），所以后移 5 - (-1) = 6位，即整个字符串移到&quot;F&quot;的后一位。</p><p><strong>这个规则有三个注意点</strong>：</p><ul><li>&quot;好后缀&quot;的位置以最后一个字符为准。假定&quot;ABCDEF&quot;的&quot;EF&quot;是好后缀，则它的位置以&quot;F&quot;为准，即5（从0开始计算）。</li><li>如果&quot;好后缀&quot;在搜索词中只出现一次，则它的上一次出现位置为 -1。比如，&quot;EF&quot;在&quot;ABCDEF&quot;之中只出现一次，则它的上一次出现位置为-1（即未出现）。</li><li>如果&quot;好后缀&quot;有多个，则除了最长的那个&quot;好后缀&quot;，其他&quot;好后缀&quot;的上一次出现位置必须在头部。比如，假定&quot;BABCDAB&quot;的&quot;好后缀&quot;是&quot;DAB&quot;、&quot;AB&quot;、&quot;B&quot;，请问这时&quot;好后缀&quot;的上一次出现位置是什么？回答是，此时采用的好后缀是&quot;B&quot;，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个&quot;好后缀&quot;只出现一次，则可以把搜索词改写成如下形式进行位置计算&quot;(DA)BABCDAB&quot;，即虚拟加入最前面的&quot;DA&quot;。</li></ul><p>回到上文的这个例子。此时，所有的&quot;好后缀&quot;（MPLE、PLE、LE、E）之中，只有&quot;E&quot;在&quot;EXAMPLE&quot;还出现在头部，所以后移 6 - 0 = 6位。</p><p><img src="'+_+'" alt="error.图片加载失败"></p><p>可以看到，&quot;坏字符规则&quot;只能移3位，&quot;好后缀规则&quot;可以移6位。所以，Boyer-Moore算法的基本思想是，每次后移这两个规则之中的较大值。</p><p>更巧妙的是，这两个规则的移动位数，只与搜索词有关，与原字符串无关。因此，可以预先计算生成《坏字符规则表》和《好后缀规则表》。使用时，只要查表比较一下就可以了。</p><p><img src="'+d+'" alt="error.图片加载失败"></p><p>继续从尾部开始比较，&quot;P&quot;与&quot;E&quot;不匹配，因此&quot;P&quot;是&quot;坏字符&quot;。根据&quot;坏字符规则&quot;，后移 6 - 4 = 2位。</p><p><img src="'+b+'" alt="error.图片加载失败"></p><p>从尾部开始逐位比较，发现全部匹配，于是搜索结束。如果还要继续查找（即找出全部匹配），则根据&quot;好后缀规则&quot;，后移 6 - 0 = 6位，即头部的&quot;E&quot;移到尾部的&quot;E&quot;的位置。</p><blockquote><p>从上面的示例描述可以看出，Boyer–Moore 算法的精妙之处在于，其通过两种启示规则来计算后移位数，且其计算过程只与模式 P 有关，而与文本 T 无关。因此，在对模式 P 进行预处理时，可预先生成 &quot;坏字符规则之向后位移表&quot; 和 &quot;好后缀规则之向后位移表&quot;，在具体匹配时仅需查表比较两者中最大的位移即可。</p></blockquote><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><ul><li><a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore%5C_string%5C_search%5C_algorithm.html" target="_blank" rel="noreferrer">http://www.ruanyifeng.com/blog/2013/05/boyer-moore\\_string\\_search\\_algorithm.html</a></li><li><a href="https://www.cnblogs.com/gaochundong/p/boyer%5C_moore%5C_string%5C_matching%5C_algorithm.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/gaochundong/p/boyer\\_moore\\_string\\_matching\\_algorithm.html</a></li></ul><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',59)]))}const C=t(P,[["render",E]]);export{k as __pageData,C as default};
