import{_ as e,c as t,ai as r,o}from"./chunks/framework.BrYByd3F.js";const i="/vitepress-blog-template/images/alg/alg-domain-char-match-11.png",l="/vitepress-blog-template/images/alg/alg-domain-char-match-12.png",c="/vitepress-blog-template/images/alg/alg-domain-char-1.gif",_=JSON.parse('{"title":"字符串匹配 - Overview","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/alg-domain-char-match.md","filePath":"algorithm/alg-domain-char-match.md","lastUpdated":1737706346000}'),n={name:"algorithm/alg-domain-char-match.md"};function h(m,a,s,d,p,g){return o(),t("div",null,a[0]||(a[0]=[r('<h1 id="字符串匹配-overview" tabindex="-1">字符串匹配 - Overview <a class="header-anchor" href="#字符串匹配-overview" aria-label="Permalink to &quot;字符串匹配 - Overview&quot;">​</a></h1><blockquote><p>字符串匹配(String Matchiing)也称字符串搜索(String Searching)是字符串算法中重要的一种，是指从一个大字符串或文本中找到模式串出现的位置。</p></blockquote><h2 id="字符串匹配概念" tabindex="-1">字符串匹配概念 <a class="header-anchor" href="#字符串匹配概念" aria-label="Permalink to &quot;字符串匹配概念&quot;">​</a></h2><blockquote><p>字符串匹配问题的形式定义：</p></blockquote><ul><li>文本（Text）是一个长度为 n 的数组 T[1..n]；</li><li>模式（Pattern）是一个长度为 m 且 m≤n 的数组 P[1..m]；</li><li>T 和 P 中的元素都属于有限的字母表 Σ 表；</li><li>如果 0≤s≤n-m，并且 T[s+1..s+m] = P[1..m]，即对 1≤j≤m，有 T[s+j] = P[j]，则说模式 P 在文本 T 中出现且位移为 s，且称 s 是一个有效位移（Valid Shift）。</li></ul><p><img src="'+i+'" alt="error.图片加载失败"></p><p>比如上图中，目标是找出所有在文本 T = abcabaabcabac 中模式 P = abaa 的所有出现。该模式在此文本中仅出现一次，即在位移 s = 3 处，位移 s = 3 是有效位移。</p><p>字符串匹配算法通常分为两个步骤：预处理（Preprocessing）和匹配（Matching）。所以算法的总运行时间为预处理和匹配的时间的总和。</p><p><img src="'+l+'" alt="error.图片加载失败"></p><p>上图描述了常见字符串匹配算法的预处理和匹配时间。</p><p><img src="'+c+'" alt="error.图片加载失败"></p><h2 id="字符串匹配算法" tabindex="-1">字符串匹配算法 <a class="header-anchor" href="#字符串匹配算法" aria-label="Permalink to &quot;字符串匹配算法&quot;">​</a></h2><blockquote><p>解决字符串匹配的算法包括：<code>朴素算法（Naive Algorithm）</code> 即暴力破解、<code>Rabin-Karp 算法</code>、<code>有限自动机算法（Finite Automation）</code>、 <code>Knuth-Morris-Pratt 算法（即 KMP Algorithm）</code>、<code>Boyer-Moore 算法</code>、<code>Simon 算法</code>、<code>Colussi 算法</code>、<code>Galil-Giancarlo 算法</code>、<code>Apostolico-Crochemore 算法</code>、<code>Horspool 算法</code>和 <code>Sunday 算法</code>等。</p></blockquote><ul><li><a href="https://pdai.tech/md/algorithm/alg-domain-char-match-bf.html" target="_blank" rel="noreferrer">朴素的字符串匹配算法（Naive String Matching Algorithm)</a><ul><li>朴素的字符串匹配算法又称为<strong>暴力匹配算法</strong>（Brute Force Algorithm），最为简单的字符串匹配算法</li></ul></li><li><a href="https://pdai.tech/md/algorithm/alg-domain-char-match-kmp.html" target="_blank" rel="noreferrer">Knuth-Morris-Pratt 字符串匹配算法（即 KMP 算法）</a><ul><li>Knuth-Morris-Pratt算法（简称KMP）是最常用的字符串匹配算法之一</li></ul></li><li><a href="https://pdai.tech/md/algorithm/alg-domain-char-match-bm.html" target="_blank" rel="noreferrer">Boyer-Moore 字符串匹配算法</a><ul><li>各种文本编辑器的&quot;查找&quot;功能（Ctrl+F），大多采用Boyer-Moore算法，效率非常高</li></ul></li><li><a href="https://pdai.tech/md/algorithm/alg-domain-char-match-st.html" target="_blank" rel="noreferrer">字符串匹配 - 文本预处理：后缀树（Suffix Tree）</a><ul><li>上述字符串匹配算法(朴素的字符串匹配算法, KMP 算法, Boyer-Moore算法)均是通过对<strong>模式（Pattern）字符串进行预处理</strong>的方式来加快搜索速度。对 Pattern 进行预处理的最优复杂度为 O(m)，其中 m 为 Pattern 字符串的长度。那么，有没有对文本（Text）进行预处理的算法呢？本文即将介绍一种<strong>对 Text 进行预处理</strong>的字符串匹配算法：后缀树（Suffix Tree）</li></ul></li></ul><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',15)]))}const b=e(n,[["render",h]]);export{_ as __pageData,b as default};
