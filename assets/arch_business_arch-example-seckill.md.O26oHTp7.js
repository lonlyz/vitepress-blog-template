import{_ as a,c as t,ai as r,o as p}from"./chunks/framework.BrYByd3F.js";const f=JSON.parse('{"title":"【秒杀抽奖】秒杀系统设计","description":"","frontmatter":{},"headers":[],"relativePath":"arch/business/arch-example-seckill.md","filePath":"arch/business/arch-example-seckill.md","lastUpdated":1737706346000}'),l={name:"arch/business/arch-example-seckill.md"};function i(n,e,o,s,c,h){return p(),t("div",null,e[0]||(e[0]=[r('<h1 id="【秒杀抽奖】秒杀系统设计" tabindex="-1">【秒杀抽奖】秒杀系统设计 <a class="header-anchor" href="#【秒杀抽奖】秒杀系统设计" aria-label="Permalink to &quot;【秒杀抽奖】秒杀系统设计&quot;">​</a></h1><p>提示</p><p>这个章节会重新梳理。@pdai</p><h2 id="秒杀小结" tabindex="-1">秒杀小结 <a class="header-anchor" href="#秒杀小结" aria-label="Permalink to &quot;秒杀小结&quot;">​</a></h2><p><strong>秒杀特点：</strong></p><p>短时间内，大量用户涌入，集中读和写有限的库存。</p><p><strong>解决方案：</strong></p><p>层层拦截，将请求尽量拦截在系统上游，避免将锁冲落到数据库上。</p><p>产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求； JS层面，限制用户在x秒之内只能提交一次请求，比如微信摇一摇抢红包。 基本可以拦截80%的请求。</p><ul><li>第二层：站点层面的请求拦截（nginx层，写流控模块）</li></ul><p>怎么防止程序员写for循环调用，有去重依据么? IP? cookie-id? …想复杂了，这类业务都需要登录，用uid即可。在站点层面，对uid进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储（这样计数会不准，但最简单，比如guava本地缓存）。一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。 对于5s内的无效请求，统一返回错误提示或错误页面。</p><p>这个方式拦住了写for循环发HTTP请求的程序员，有些高端程序员（黑客）控制了10w个肉鸡，手里有10w个uid，同时发请求（先不考虑实名制的问题，小米抢手机不需要实名制），这下怎么办，站点层按照uid限流拦不住了。</p><ul><li>第三层：服务层拦截</li></ul><p>方案一：写请求放到队列中，每次只透有限的写请求到数据层，如果成功了再放下一批，直到库存不够，队列里的写请求全部返回“已售完”。</p><p>方案二：或采用漏斗机制，只放一倍的流量进来，多余的返回“已售完”，把写压力转换成读压力。 读请求，用cache，redis单机可以抗10W QPS,用异步线程定时更新缓存里的库存值。</p><p>还有提示“模糊化”，比如火车余票查询，票剩了58张，还是26张，你真的关注么，其实我们只关心有票和无票。</p><ul><li>第四层：数据库层</li></ul><p>浏览器拦截了80%，站点层拦截了99.9%并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。 db基本就没什么压力了，通过自身锁机制来控制，避免出现超卖。</p><p><strong>总结：</strong></p><ol><li>尽量将请求拦截在系统上游（越上游越好）；</li><li>读多写少的多使用缓存（缓存抗读压力）；</li></ol><p><strong>参考资料：</strong></p><p><a href="http://www.infoq.com/cn/articles/flash-deal-architecture-optimization" target="_blank" rel="noreferrer">http://www.infoq.com/cn/articles/flash-deal-architecture-optimization</a></p><p><a href="https://www.jianshu.com/p/df4fbecb1a4b" target="_blank" rel="noreferrer">https://www.jianshu.com/p/df4fbecb1a4b</a></p><p><a href="https://my.oschina.net/xianggao/blog/524943" target="_blank" rel="noreferrer">https://my.oschina.net/xianggao/blog/524943</a></p><p><a href="https://www.cnblogs.com/jifeng/p/5264268.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/jifeng/p/5264268.html</a></p><p><a href="https://blog.csdn.net/Luomingkui1109/article/details/77432192" target="_blank" rel="noreferrer">https://blog.csdn.net/Luomingkui1109/article/details/77432192</a></p><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',27)]))}const u=a(l,[["render",i]]);export{f as __pageData,u as default};
