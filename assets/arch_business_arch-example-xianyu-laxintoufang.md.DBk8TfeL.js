import{_ as e,c as r,ai as t,o as p}from"./chunks/framework.BrYByd3F.js";const i="/vitepress-blog-template/images/arch/arch-e-laxin-xianyu-1.png",s="/vitepress-blog-template/images/arch/arch-e-laxin-xianyu-2.png",n="/vitepress-blog-template/images/arch/arch-e-laxin-xianyu-3.png",l="/vitepress-blog-template/images/arch/arch-e-laxin-xianyu-4.png",o="/vitepress-blog-template/images/arch/arch-e-laxin-xianyu-5.png",h="/vitepress-blog-template/images/arch/arch-e-laxin-xianyu-6.png",c="/vitepress-blog-template/images/arch/arch-e-laxin-xianyu-7.png",q=JSON.parse('{"title":"【拉新投放】闲鱼-拉新投放系统如何设计","description":"","frontmatter":{},"headers":[],"relativePath":"arch/business/arch-example-xianyu-laxintoufang.md","filePath":"arch/business/arch-example-xianyu-laxintoufang.md","lastUpdated":1737706346000}'),m={name:"arch/business/arch-example-xianyu-laxintoufang.md"};function d(u,a,b,x,_,g){return p(),r("div",null,a[0]||(a[0]=[t('<h1 id="【拉新投放】闲鱼-拉新投放系统如何设计" tabindex="-1">【拉新投放】闲鱼-拉新投放系统如何设计 <a class="header-anchor" href="#【拉新投放】闲鱼-拉新投放系统如何设计" aria-label="Permalink to &quot;【拉新投放】闲鱼-拉新投放系统如何设计&quot;">​</a></h1><blockquote><p>闲鱼目前已经是国内最大的闲置物品交易平台。随着闲鱼体量的增长和用户规模不断扩大，闲鱼App上的一个普通banner抑或是feeds中的一张普通的卡片，每天都可能被数以千万计的人看到。为了更好地服务好广大的用户群体，更加个性化的内容推荐和更加精细化的素材投放就显得尤为必要了。今天我们来聊一聊如何设计一个可以精准触达用户、运营快速试错、解放开发生产力的投放系统。</p></blockquote><h2 id="思路" tabindex="-1">思路 <a class="header-anchor" href="#思路" aria-label="Permalink to &quot;思路&quot;">​</a></h2><p>投放是什么? 举例来说，往城市广场的一块广告牌上在不同时段不同场景下更换广告画就是一种投放，当然互联网技术带来了人的维度，不同用户看到的广告画可能也是不一样的。我们来看下这样一个系统应该包含哪些功能。</p><p>1、我们把“城市广场上的那块广告牌”叫资源位，那么需要一个服务端接口来获取需要透出的素材。 2、不同资源位需要透出的素材格式可能是不一样的，可能是banner，可能是feeds，可能是运营自定义的手填数据，可能是任何合理的数据结构。 3、同一个资源位，不同时段，针对不同平台、不同人群，透出的素材可能是不一样的，那么就需要有一个服务来在一堆素材中筛选出适合资源位的内容。在资源位命中了多个素材的时候，还需要有一些机制来裁决出最终透出的那一个。</p><h2 id="详细设计" tabindex="-1">详细设计 <a class="header-anchor" href="#详细设计" aria-label="Permalink to &quot;详细设计&quot;">​</a></h2><p>我们设计的投放系统扮演的是前端实体资源位和后端多种数据源之间的桥梁的角色。它负责从各个业务数据源中根据一定规则筛选出在特定资源位上需要透出的数据，基本的数据流如下图所示：</p><p><img src="'+i+'" alt="error.图片加载失败"></p><p>图中的这些概念在我们的系统中是怎么分解的呢?</p><h3 id="资源位" tabindex="-1">资源位 <a class="header-anchor" href="#资源位" aria-label="Permalink to &quot;资源位&quot;">​</a></h3><p>所谓资源位，在我们这个体系内，是指前端页面上的实体坑位。是技术同学在产品开发中创建的。理所当然，资源位需要消费的数据结构是在开发阶段就确定了，比如banner、feeds或者结构非常灵活的手填数据等。</p><p>在我们这个体系里，我们用一个 schema 描述资源位需要消费的数据结构。</p><p><img src="'+s+'" alt="error.图片加载失败"></p><p>这个 schema 是用 json 描述的。技术同学在前端页面上开发实体资源位后，需要在我们的系统中创建对应的虚拟资源位，并通过一个图形化的 json schema 编辑器来定义这个资源位需要消费的数据结构。</p><p><img src="'+n+'" alt="error.图片加载失败"></p><h3 id="投放物料" tabindex="-1">投放物料 <a class="header-anchor" href="#投放物料" aria-label="Permalink to &quot;投放物料&quot;">​</a></h3><p>上述 schema 定义了一个资源位所需要消费的数据的格式。但是光有 schema 是不够的，因为资源位要消费的是数据，而不是数据结构本身。在我们的系统中，我们用一个动态表单模块根据schema生成动态的表单，产品运营同学通过动态表单生产的数据，我们称之为投放物料。资源位消费的就是投放物料。</p><p>对于一些手填数据，表单直接产生的数据就是资源位可用的了。但是对于 Feeds 之类的，表单往往只能定义 Feeds 的一些诸如选品等特征字段。对于这类特殊类型的数据源，服务端就不能简单的直接返回数据了，需要根据这些特征字段，做一些数据查询和数据解析工作，再返回给前端一个完整规范的数据。</p><p><img src="'+l+'" alt="error.图片加载失败"></p><h3 id="投放单元" tabindex="-1">投放单元 <a class="header-anchor" href="#投放单元" aria-label="Permalink to &quot;投放单元&quot;">​</a></h3><p>前述文章说到，同一个banner，可能对新用户投放的是红包，对年轻男孩子投放的是手机数码内容，对年轻女孩子投放的是美妆服饰。我们把这个连接了资源位、投放物料与多个投放因子的桥梁叫做投放单元。</p><p>那么投放单元需要有多少个投放因子呢? 其实是视业务而定的，我们认为基础的投放因为应该包含 投放时段、投放人群、投放平台、投放AB配置等。</p><p>当资源位向投放系统发起请求拉取数据时，投放系统在这个资源位上挂载的所有投放单元中根据投放因子筛选出命中的投放单元，最后将命中的投放单元上挂载的投放物料返回给前端的投放资源位。当命中了多个投放单元时，需要有些方法来裁决出最终胜出的那一个。这个方法简单点做，可以在投放单元中配一个权重，筛选时最后选择权重高的那个，也可以引入算法决策，根据投放的 ctr 数据做排序。</p><p><img src="'+o+'" alt="error.图片加载失败"></p><h3 id="投放计划" tabindex="-1">投放计划 <a class="header-anchor" href="#投放计划" aria-label="Permalink to &quot;投放计划&quot;">​</a></h3><p>投放计划是产品运营对多个资源位管理形式。简单来说，一个投放计划下，可以挂载多个关联的资源位。试想一下，一次大促活动可能涉及到几十个资源位的投放，将这些资源位组织到同一个投放计划中进行管理，可以更加方便操作以及查看投放效果。</p><h3 id="端侧接入" tabindex="-1">端侧接入 <a class="header-anchor" href="#端侧接入" aria-label="Permalink to &quot;端侧接入&quot;">​</a></h3><p>对于前端来说，我们希望通过提供一个封装的npm包，通过简单调用，传入resourceId(资源位ID) 即可获取数据。</p><p><img src="'+h+'" alt="error.图片加载失败"></p><p>这种调用方式对业务调用方来说是比较优雅的，但是对页面性能来说却是不省心的。因为一个页面往往由很多个资源位组成，每个资源位单独发起请求就会形成大量的并发请求，不仅页面性能会降低，还会对服务器产生比较大的qps压力。</p><p>针对这种情况，我们做了一个小优化。服务端提供一个批量查询的接口，前端SDK内部，每10ms 对模块的请求调用做一次聚合，将单个资源位的数据获取转化成批量的查询。负面影响是对部分资源位的数据加载造成最大10ms的延时，优点是提升了页面整体的性能，有效减小了服务端QPS压力。</p><p><img src="'+c+'" alt="error.图片加载失败"></p><h2 id="效果" tabindex="-1">效果 <a class="header-anchor" href="#效果" aria-label="Permalink to &quot;效果&quot;">​</a></h2><p>上述投放系统在闲鱼拉新业务实践中稳定了run了半年多，为闲鱼应用内的数百个资源位提供投放能力支持，每天服务千万级别的闲鱼用户。</p><p>既实现了资源位的精细化投放，提高了单个资源位的利用率，又赋能运营更自由地进行各种拉新投放实验，减小试错成本，还减少了技术同学频繁参与运营实验改造的开发工作量，解放了技术同学的生产力。</p><h2 id="写在最后" tabindex="-1">写在最后 <a class="header-anchor" href="#写在最后" aria-label="Permalink to &quot;写在最后&quot;">​</a></h2><p>上述文章介绍了一个简易的投放系统的设计思路，本质上是一个连接前端实体资源位和服务端多种数据源的桥梁的设计。</p><p>其中有很多能力是依赖了团队内部其它同学努力的成果，比如： 1、描述资源位数据结构的 json schema如何设计</p><p>2、根据json schema动态生成的表单怎么实现</p><p>3、人群校验的服务和能力</p><p>4、AB测试的能力</p><p>5、feeds 的选品服务</p><p>6、个性化动态banner能力</p><p>这个系统还有很多可以优化的点，比如数据回流如何做得更好，怎样引入算法能力对策略筛选进行优化等等，都是未来值得努力的方向。</p><h2 id="文章来源" tabindex="-1">文章来源 <a class="header-anchor" href="#文章来源" aria-label="Permalink to &quot;文章来源&quot;">​</a></h2><p>转载说明:</p><ul><li>版权声明：本文为CSDN博主「闲鱼技术」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</li><li>原文链接：<a href="https://blog.csdn.net/weixin%5C_38912070/article/details/93816577" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin\\_38912070/article/details/93816577</a></li></ul><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',48)]))}const k=e(m,[["render",d]]);export{q as __pageData,k as default};
