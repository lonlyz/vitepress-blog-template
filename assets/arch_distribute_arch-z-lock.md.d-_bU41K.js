import{_ as a}from"./chunks/zk-1.DnoSvoSW.js";import{_ as n,c as e,ai as t,o as p}from"./chunks/framework.BrYByd3F.js";const k=JSON.parse('{"title":"分布式系统 - 分布式锁及实现方案","description":"","frontmatter":{},"headers":[],"relativePath":"arch/distribute/arch-z-lock.md","filePath":"arch/distribute/arch-z-lock.md","lastUpdated":1737706346000}'),l={name:"arch/distribute/arch-z-lock.md"};function i(o,s,r,c,d,u){return p(),e("div",null,s[0]||(s[0]=[t(`<h1 id="分布式系统-分布式锁及实现方案" tabindex="-1">分布式系统 - 分布式锁及实现方案 <a class="header-anchor" href="#分布式系统-分布式锁及实现方案" aria-label="Permalink to &quot;分布式系统 - 分布式锁及实现方案&quot;">​</a></h1><blockquote><p>本文主要介绍分布式锁的概念和分布式锁的设计原则，以及常见的分布式锁的实现方式。@pdai</p></blockquote><h2 id="什么是分布式锁" tabindex="-1">什么是分布式锁 <a class="header-anchor" href="#什么是分布式锁" aria-label="Permalink to &quot;什么是分布式锁&quot;">​</a></h2><blockquote><p>要介绍分布式锁，首先要提到与分布式锁相对应的是线程锁、进程锁。</p></blockquote><ul><li><p><strong>线程锁</strong>：主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如synchronized是共享对象头，显示锁Lock是共享某个变量（state）。</p></li><li><p><strong>进程锁</strong>：为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。</p></li><li><p><strong>分布式锁</strong>：当多个进程不在同一个系统中(比如分布式系统中控制共享资源访问)，用分布式锁控制多个进程对资源的访问。</p></li></ul><h2 id="分布式锁的设计原则" tabindex="-1">分布式锁的设计原则 <a class="header-anchor" href="#分布式锁的设计原则" aria-label="Permalink to &quot;分布式锁的设计原则&quot;">​</a></h2><blockquote><p>分布式锁的最小设计原则：<strong>安全性</strong>和<strong>有效性</strong></p></blockquote><p><a href="https://redis.io/docs/reference/patterns/distributed-locks/" target="_blank" rel="noreferrer">Redis的官网在新窗口打开</a>上对使用分布式锁提出至少需要满足如下三个要求：</p><ol><li><strong>互斥</strong>（属于安全性）：在任何给定时刻，只有一个客户端可以持有锁。</li><li><strong>无死锁</strong>（属于有效性）：即使锁定资源的客户端崩溃或被分区，也总是可以获得锁；通常通过超时机制实现。</li><li><strong>容错性</strong>（属于有效性）：只要大多数 Redis 节点都启动，客户端就可以获取和释放锁。</li></ol><p>除此之外，分布式锁的设计中还可以/需要考虑：</p><ol><li>加锁解锁的<strong>同源性</strong>：A加的锁，不能被B解锁</li><li>获取锁是<strong>非阻塞</strong>的：如果获取不到锁，不能无限期等待；</li><li><strong>高性能</strong>：加锁解锁是高性能的</li></ol><h2 id="分布式锁的实现方案" tabindex="-1">分布式锁的实现方案 <a class="header-anchor" href="#分布式锁的实现方案" aria-label="Permalink to &quot;分布式锁的实现方案&quot;">​</a></h2><blockquote><p>就体系的角度而言，谈谈常见的分布式锁的实现方案。</p></blockquote><ul><li><strong>基于数据库实现分布式锁</strong><ul><li>基于数据库表（锁表，很少使用）</li><li>乐观锁(基于版本号)</li><li>悲观锁(基于排它锁)</li></ul></li><li><strong>基于 redis 实现分布式锁</strong>: <ul><li>单个Redis实例：setnx(key,当前时间+过期时间) + Lua</li><li>Redis集群模式：Redlock</li></ul></li><li><strong>基于 zookeeper实现分布式锁</strong><ul><li>临时有序节点来实现的分布式锁,Curator</li></ul></li><li><strong>基于 Consul 实现分布式锁</strong></li></ul><h2 id="基于数据库如何实现分布式锁-有什么缺陷" tabindex="-1">基于数据库如何实现分布式锁？有什么缺陷？ <a class="header-anchor" href="#基于数据库如何实现分布式锁-有什么缺陷" aria-label="Permalink to &quot;基于数据库如何实现分布式锁？有什么缺陷？&quot;">​</a></h2><blockquote><p>基于数据库如何实现分布式锁？有什么缺陷？</p></blockquote><h3 id="基于数据库表-锁表-很少使用" tabindex="-1">基于数据库表（锁表，很少使用） <a class="header-anchor" href="#基于数据库表-锁表-很少使用" aria-label="Permalink to &quot;基于数据库表（锁表，很少使用）&quot;">​</a></h3><p>最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们想要获得锁的时候，就可以在该表中增加一条记录，想要释放锁的时候就删除这条记录。</p><p>为了更好的演示，我们先创建一张数据库表，参考如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE database_lock (</span></span>
<span class="line"><span>	\`id\` BIGINT NOT NULL AUTO_INCREMENT,</span></span>
<span class="line"><span>	\`resource\` int NOT NULL COMMENT &#39;锁定的资源&#39;,</span></span>
<span class="line"><span>	\`description\` varchar(1024) NOT NULL DEFAULT &quot;&quot; COMMENT &#39;描述&#39;,</span></span>
<span class="line"><span>	PRIMARY KEY (id),</span></span>
<span class="line"><span>	UNIQUE KEY uiq_idx_resource (resource)</span></span>
<span class="line"><span>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;数据库分布式锁表&#39;;</span></span></code></pre></div><p>当我们想要获得锁时，可以插入一条数据：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>INSERT INTO database_lock(resource, description) VALUES (1, &#39;lock&#39;);</span></span></code></pre></div><p>当需要释放锁的时，可以删除这条数据：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DELETE FROM database_lock WHERE resource=1;</span></span></code></pre></div><h3 id="基于悲观锁" tabindex="-1">基于悲观锁 <a class="header-anchor" href="#基于悲观锁" aria-label="Permalink to &quot;基于悲观锁&quot;">​</a></h3><p><strong>悲观锁实现思路</strong>？</p><ol><li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li><li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。</li><li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li><li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li></ol><p><strong>以MySQL InnoDB中使用悲观锁为例</strong>？</p><p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//0.开始事务</span></span>
<span class="line"><span>begin;/begin work;/start transaction; (三者选一就可以)</span></span>
<span class="line"><span>//1.查询出商品信息</span></span>
<span class="line"><span>select status from t_goods where id=1 for update;</span></span>
<span class="line"><span>//2.根据商品信息生成订单</span></span>
<span class="line"><span>insert into t_orders (id,goods_id) values (null,1);</span></span>
<span class="line"><span>//3.修改商品status为2</span></span>
<span class="line"><span>update t_goods set status=2;</span></span>
<span class="line"><span>//4.提交事务</span></span>
<span class="line"><span>commit;/commit work;</span></span></code></pre></div><p>上面的查询语句中，我们使用了<code>select…for update</code>的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>上面我们提到，使用<code>select…for update</code>会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p><h3 id="基于乐观锁" tabindex="-1">基于乐观锁 <a class="header-anchor" href="#基于乐观锁" aria-label="Permalink to &quot;基于乐观锁&quot;">​</a></h3><p>乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p><p><strong>以使用版本号实现乐观锁为例？</strong></p><p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1.查询出商品信息</span></span>
<span class="line"><span>select (status,status,version) from t_goods where id=#{id}</span></span>
<span class="line"><span>2.根据商品信息生成订单</span></span>
<span class="line"><span>3.修改商品status为2</span></span>
<span class="line"><span>update t_goods </span></span>
<span class="line"><span>set status=2,version=version+1</span></span>
<span class="line"><span>where id=#{id} and version=#{version};</span></span></code></pre></div><p>需要注意的是，乐观锁机制往往基于系统中数据存储逻辑，因此也具备一定的局限性。由于乐观锁机制是在我们的系统中实现的，对于来自外部系统的用户数据更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况，并进行相应的调整（如将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开）。</p><ul><li><strong>缺陷</strong></li></ul><p>对数据库依赖，开销问题，行锁变表锁问题，无法解决数据库单点和可重入的问题。</p><h2 id="基于redis如何实现分布式锁-有什么缺陷" tabindex="-1">基于redis如何实现分布式锁？有什么缺陷？ <a class="header-anchor" href="#基于redis如何实现分布式锁-有什么缺陷" aria-label="Permalink to &quot;基于redis如何实现分布式锁？有什么缺陷？&quot;">​</a></h2><blockquote><p>基于redis如何实现分布式锁？这里一定要看<a href="https://redis.io/docs/reference/patterns/distributed-locks/" target="_blank" rel="noreferrer">Redis的官网在新窗口打开</a>的分布式锁的实现这篇文章。</p></blockquote><h3 id="set-nx-px-lua" tabindex="-1">set NX PX + Lua <a class="header-anchor" href="#set-nx-px-lua" aria-label="Permalink to &quot;set NX PX + Lua&quot;">​</a></h3><p><strong>加锁</strong>： set NX PX + 重试 + 重试间隔</p><p>向Redis发起如下命令: <code>SET productId:lock 0xx9p03001 NX PX 30000</code> 其中，&quot;productId&quot;由自己定义，可以是与本次业务有关的id，&quot;0xx9p03001&quot;是一串随机值，必须保证全局唯一(原因在后文中会提到)，“NX&quot;指的是当且仅当key(也就是案例中的&quot;productId:lock”)在Redis中不存在时，返回执行成功，否则执行失败。&quot;PX 30000&quot;指的是在30秒后，key将被自动删除。执行命令后返回成功，表明服务成功的获得了锁。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@Override</span></span>
<span class="line"><span>public boolean lock(String key, long expire, int retryTimes, long retryDuration) {</span></span>
<span class="line"><span>    // use JedisCommands instead of setIfAbsense</span></span>
<span class="line"><span>    boolean result = setRedis(key, expire);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // retry if needed</span></span>
<span class="line"><span>    while ((!result) &amp;&amp; retryTimes-- &gt; 0) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            log.debug(&quot;lock failed, retrying...&quot; + retryTimes);</span></span>
<span class="line"><span>            Thread.sleep(retryDuration);</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // use JedisCommands instead of setIfAbsense</span></span>
<span class="line"><span>        result = setRedis(key, expire);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>private boolean setRedis(String key, long expire) {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>        RedisCallback&lt;String&gt; redisCallback = connection -&gt; {</span></span>
<span class="line"><span>            JedisCommands commands = (JedisCommands) connection.getNativeConnection();</span></span>
<span class="line"><span>            String uuid = SnowIDUtil.uniqueStr();</span></span>
<span class="line"><span>            lockFlag.set(uuid);</span></span>
<span class="line"><span>            return commands.set(key, uuid, NX, PX, expire); // 看这里</span></span>
<span class="line"><span>        };</span></span>
<span class="line"><span>        String result = redisTemplate.execute(redisCallback);</span></span>
<span class="line"><span>        return !StringUtil.isEmpty(result);</span></span>
<span class="line"><span>    } catch (Exception e) {</span></span>
<span class="line"><span>        log.error(&quot;set redis occurred an exception&quot;, e);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return false;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><strong>解锁</strong>：采用lua脚本</p><p>在删除key之前，一定要判断服务A持有的value与Redis内存储的value是否一致。如果贸然使用服务A持有的key来删除锁，则会误将服务B的锁释放掉。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>if redis.call(&quot;get&quot;, KEYS[1])==ARGV[1] then</span></span>
<span class="line"><span>	return redis.call(&quot;del&quot;, KEYS[1])</span></span>
<span class="line"><span>else</span></span>
<span class="line"><span>	return 0</span></span>
<span class="line"><span>end</span></span></code></pre></div><h3 id="基于redlock实现分布式锁" tabindex="-1">基于RedLock实现分布式锁 <a class="header-anchor" href="#基于redlock实现分布式锁" aria-label="Permalink to &quot;基于RedLock实现分布式锁&quot;">​</a></h3><blockquote><p>这是Redis作者推荐的分布式集群情况下的方式，请看这篇文章<a href="http://antirez.com/news/101" target="_blank" rel="noreferrer">Is Redlock safe?在新窗口打开</a></p></blockquote><p>假设有两个服务A、B都希望获得锁，有一个包含了5个redis master的Redis Cluster，执行过程大致如下:</p><ol><li>客户端获取当前时间戳，单位: 毫秒</li><li>服务A轮寻每个master节点，尝试创建锁。(这里锁的过期时间比较短，一般就几十毫秒) RedLock算法会尝试在大多数节点上分别创建锁，假如节点总数为n，那么大多数节点指的是n/2+1。</li><li>客户端计算成功建立完锁的时间，如果建锁时间小于超时时间，就可以判定锁创建成功。如果锁创建失败，则依次(遍历master节点)删除锁。</li><li>只要有其它服务创建过分布式锁，那么当前服务就必须轮寻尝试获取锁。</li></ol><h3 id="基于redis的客户端" tabindex="-1">基于Redis的客户端 <a class="header-anchor" href="#基于redis的客户端" aria-label="Permalink to &quot;基于Redis的客户端&quot;">​</a></h3><blockquote><p>这里Redis的客户端（Jedis, Redisson, Lettuce等）都是基于上述两类形式来实现分布式锁的，只是两类形式的封装以及一些优化（比如Redisson的watch dog)。</p></blockquote><p>以基于Redisson实现分布式锁为例（支持了 单实例、Redis哨兵、redis cluster、redis master-slave等各种部署架构）：</p><p><strong>特色</strong>？</p><ol><li>redisson所有指令都通过lua脚本执行，保证了操作的原子性</li><li>redisson设置了watchdog看门狗，“看门狗”的逻辑保证了没有死锁发生</li><li>redisson支持Redlock的实现方式。</li></ol><p><strong>过程</strong>？</p><ol><li>线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。</li><li>线程去获取锁，获取失败: 订阅了解锁消息，然后再尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。</li></ol><p><strong>互斥</strong>？</p><p>如果这个时候客户端B来尝试加锁，执行了同样的一段lua脚本。第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在。接着第二个if判断，判断myLock锁key的hash数据结构中，是否包含客户端B的ID，但明显没有，那么客户端B会获取到pttl myLock返回的一个数字，代表myLock这个锁key的剩余生存时间。此时客户端B会进入一个while循环，不听的尝试加锁。</p><p><strong>watch dog自动延时机制</strong>？</p><p>​客户端A加锁的锁key默认生存时间只有30秒，如果超过了30秒，客户端A还想一直持有这把锁，怎么办？其实只要客户端A一旦加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果客户端A还持有锁key，那么就会不断的延长锁key的生存时间。</p><p><strong>可重入</strong>？</p><p>每次lock会调用incrby，每次unlock会减一。</p><h3 id="进一步理解" tabindex="-1">进一步理解 <a class="header-anchor" href="#进一步理解" aria-label="Permalink to &quot;进一步理解&quot;">​</a></h3><ol><li>借助Redis实现分布式锁时，有一个共同的缺陷: 当获取锁被拒绝后，需要不断的循环，重新发送获取锁(创建key)的请求，直到请求成功。这就造成空转，浪费宝贵的CPU资源。</li><li>RedLock算法本身有争议，具体看这篇文章<a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noreferrer">How to do distributed locking在新窗口打开</a> 以及作者的回复<a href="http://antirez.com/news/101" target="_blank" rel="noreferrer">Is Redlock safe?在新窗口打开</a></li></ol><h2 id="基于zookeeper如何实现分布式锁" tabindex="-1">基于zookeeper如何实现分布式锁？ <a class="header-anchor" href="#基于zookeeper如何实现分布式锁" aria-label="Permalink to &quot;基于zookeeper如何实现分布式锁？&quot;">​</a></h2><p>说几个核心点：</p><ul><li><strong>顺序节点</strong></li></ul><p>创建一个用于发号的节点“/test/lock”，然后以它为父亲节点的前缀为“/test/lock/seq-”依次发号：</p><p><img src="`+a+'" alt="error.图片加载失败"></p><ul><li><strong>获得最小号得锁</strong></li></ul><p>由于序号的递增性，可以规定排号最小的那个获得锁。所以，每个线程在尝试占用锁之前，首先判断自己是排号是不是当前最小，如果是，则获取锁。</p><ul><li><strong>节点监听机制</strong></li></ul><p>每个线程抢占锁之前，先抢号创建自己的ZNode。同样，释放锁的时候，就需要删除抢号的Znode。抢号成功后，如果不是排号最小的节点，就处于等待通知的状态。等谁的通知呢？不需要其他人，只需要等前一个Znode 的通知就可以了。当前一个Znode 删除的时候，就是轮到了自己占有锁的时候。第一个通知第二个、第二个通知第三个，击鼓传花似的依次向后。</p><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><ul><li><a href="http://antirez.com/news/101" target="_blank" rel="noreferrer">Is Redlock safe?在新窗口打开</a></li></ul><p><a href="https://juejin.im/post/6872001566111596552" target="_blank" rel="noreferrer">https://juejin.im/post/6872001566111596552</a></p><p><a href="https://juejin.im/post/6872886438325813256" target="_blank" rel="noreferrer">https://juejin.im/post/6872886438325813256</a></p><p><a href="https://juejin.im/post/6850418111700680712" target="_blank" rel="noreferrer">https://juejin.im/post/6850418111700680712</a></p><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',83)]))}const b=n(l,[["render",i]]);export{k as __pageData,b as default};
