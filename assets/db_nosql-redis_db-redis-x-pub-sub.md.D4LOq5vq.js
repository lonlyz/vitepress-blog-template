import{_ as n,a,b as e,c as p,d as t,e as l}from"./chunks/db-redis-sub-7.ByWNOYBg.js";import{_ as i,c as o,ai as r,o as c}from"./chunks/framework.BrYByd3F.js";const u="/vitepress-blog-template/images/db/redis/db-redis-sub-3.svg",b="/vitepress-blog-template/images/db/redis/db-redis-sub-4.svg",d="/vitepress-blog-template/images/db/redis/db-redis-sub-9.svg",h="/vitepress-blog-template/images/db/redis/db-redis-sub-10.svg",P=JSON.parse('{"title":"Redis进阶 - 消息传递：发布订阅模式详解","description":"","frontmatter":{},"headers":[],"relativePath":"db/nosql-redis/db-redis-x-pub-sub.md","filePath":"db/nosql-redis/db-redis-x-pub-sub.md","lastUpdated":1737706346000}'),g={name:"db/nosql-redis/db-redis-x-pub-sub.md"};function q(m,s,_,k,v,C){return c(),o("div",null,s[0]||(s[0]=[r('<h1 id="redis进阶-消息传递-发布订阅模式详解" tabindex="-1">Redis进阶 - 消息传递：发布订阅模式详解 <a class="header-anchor" href="#redis进阶-消息传递-发布订阅模式详解" aria-label="Permalink to &quot;Redis进阶 - 消息传递：发布订阅模式详解&quot;">​</a></h1><blockquote><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 @pdai</p></blockquote><h2 id="redis发布订阅简介" tabindex="-1">Redis发布订阅简介 <a class="header-anchor" href="#redis发布订阅简介" aria-label="Permalink to &quot;Redis发布订阅简介&quot;">​</a></h2><blockquote><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p></blockquote><p>Redis 的 SUBSCRIBE 命令可以让客户端订阅任意数量的频道， 每当有新信息发送到被订阅的频道时， 信息就会被发送给所有订阅指定频道的客户端。</p><p>作为例子， 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="'+n+'" alt="error.图片加载失败"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="'+a+'" alt="error.图片加载失败"></p><h2 id="发布-订阅使用" tabindex="-1">发布/订阅使用 <a class="header-anchor" href="#发布-订阅使用" aria-label="Permalink to &quot;发布/订阅使用&quot;">​</a></h2><blockquote><p>Redis有两种发布/订阅模式：</p><ul><li>基于频道(Channel)的发布/订阅</li><li>基于模式(pattern)的发布/订阅</li></ul></blockquote><h3 id="基于频道-channel-的发布-订阅" tabindex="-1">基于频道(Channel)的发布/订阅 <a class="header-anchor" href="#基于频道-channel-的发布-订阅" aria-label="Permalink to &quot;基于频道(Channel)的发布/订阅&quot;">​</a></h3><p>&quot;发布/订阅&quot;模式包含两种角色，分别是发布者和订阅者。发布者可以向指定的频道(channel)发送消息; 订阅者可以订阅一个或者多个频道(channel),所有订阅此频道的订阅者都会收到此消息。</p><p><img src="'+e+`" alt="error.图片加载失败"></p><ul><li><strong>发布者发布消息</strong></li></ul><p>发布者发布消息的命令是 publish,用法是 publish channel message，如向 channel1.1说一声hi</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>127.0.0.1:6379&gt; publish channel:1 hi</span></span>
<span class="line"><span>(integer) 1</span></span></code></pre></div><p>这样消息就发出去了。返回值表示接收这条消息的订阅者数量。发出去的消息不会被持久化，也就是有客户端订阅channel:1后只能接收到后续发布到该频道的消息，之前的就接收不到了。</p><ul><li><strong>订阅者订阅频道</strong></li></ul><p>订阅频道的命令是 subscribe，可以同时订阅多个频道，用法是 subscribe channel1 [channel2 ...],例如新开一个客户端订阅上面频道:(不会收到消息，因为不会收到订阅之前就发布到该频道的消息)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>127.0.0.1:6379&gt; subscribe channel:1</span></span>
<span class="line"><span>Reading messages... (press Ctrl-C to quit)</span></span>
<span class="line"><span>1) &quot;subscribe&quot; // 消息类型</span></span>
<span class="line"><span>2) &quot;channel:1&quot; // 频道</span></span>
<span class="line"><span>3) &quot;hi&quot; // 消息内容</span></span></code></pre></div><p>执行上面命令客户端会进入订阅状态，处于此状态下客户端不能使用除<code>subscribe</code>、<code>unsubscribe</code>、<code>psubscribe</code>和<code>punsubscribe</code>这四个属于&quot;发布/订阅&quot;之外的命令，否则会报错。</p><p>进入订阅状态后客户端可能收到3种类型的回复。每种类型的回复都包含3个值，第一个值是消息的类型，根据消类型的不同，第二个和第三个参数的含义可能不同。</p><p>消息类型的取值可能是以下3个:</p><ul><li>subscribe。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</li><li>message。表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。</li><li>unsubscribe。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非&quot;发布/订阅&quot;模式的命令了。</li></ul><h3 id="基于模式-pattern-的发布-订阅" tabindex="-1">基于模式(pattern)的发布/订阅 <a class="header-anchor" href="#基于模式-pattern-的发布-订阅" aria-label="Permalink to &quot;基于模式(pattern)的发布/订阅&quot;">​</a></h3><p>如果有某个/某些模式和这个频道匹配的话，那么所有订阅这个/这些频道的客户端也同样会收到信息。</p><ul><li><strong>用图例解释什么是基于模式的发布订阅</strong></li></ul><p>下图展示了一个带有频道和模式的例子， 其中 tweet.shop.* 模式匹配了 tweet.shop.kindle 频道和 tweet.shop.ipad 频道， 并且有不同的客户端分别订阅它们三个：</p><p><img src="`+p+'" alt="error.图片加载失败"></p><p>当有信息发送到 tweet.shop.kindle 频道时， 信息除了发送给 clientX 和 clientY 之外， 还会发送给订阅 tweet.shop.* 模式的 client123 和 client256 ：</p><p><img src="'+t+'" alt="error.图片加载失败"></p><p>另一方面， 如果接收到信息的是频道 tweet.shop.ipad ， 那么 client123 和 client256 同样会收到信息：</p><p><img src="'+l+`" alt="error.图片加载失败"></p><ul><li><strong>基于模式的例子</strong></li></ul><p>通配符中?表示1个占位符，*表示任意个占位符(包括0)，?*表示1个以上占位符。</p><p>publish发布</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>127.0.0.1:6379&gt; publish c m1</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span>127.0.0.1:6379&gt; publish c1 m1</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>127.0.0.1:6379&gt; publish c11 m1</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span>127.0.0.1:6379&gt; publish b m1</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>127.0.0.1:6379&gt; publish b1 m1</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>127.0.0.1:6379&gt; publish b11 m1</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>127.0.0.1:6379&gt; publish d m1</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span>127.0.0.1:6379&gt; publish d1 m1</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>127.0.0.1:6379&gt; publish d11 m1</span></span>
<span class="line"><span>(integer) 1</span></span></code></pre></div><p>psubscribe订阅</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>127.0.0.1:6379&gt; psubscribe c? b* d?*</span></span>
<span class="line"><span>Reading messages... (press Ctrl-C to quit)</span></span>
<span class="line"><span>1) &quot;psubscribe&quot;</span></span>
<span class="line"><span>2) &quot;c?&quot;</span></span>
<span class="line"><span>3) (integer) 1</span></span>
<span class="line"><span>1) &quot;psubscribe&quot;</span></span>
<span class="line"><span>2) &quot;b*&quot;</span></span>
<span class="line"><span>3) (integer) 2</span></span>
<span class="line"><span>1) &quot;psubscribe&quot;</span></span>
<span class="line"><span>2) &quot;d?*&quot;</span></span>
<span class="line"><span>3) (integer) 3</span></span>
<span class="line"><span>1) &quot;pmessage&quot;</span></span>
<span class="line"><span>2) &quot;c?&quot;</span></span>
<span class="line"><span>3) &quot;c1&quot;</span></span>
<span class="line"><span>4) &quot;m1&quot;</span></span>
<span class="line"><span>1) &quot;pmessage&quot;</span></span>
<span class="line"><span>2) &quot;b*&quot;</span></span>
<span class="line"><span>3) &quot;b&quot;</span></span>
<span class="line"><span>4) &quot;m1&quot;</span></span>
<span class="line"><span>1) &quot;pmessage&quot;</span></span>
<span class="line"><span>2) &quot;b*&quot;</span></span>
<span class="line"><span>3) &quot;b1&quot;</span></span>
<span class="line"><span>4) &quot;m1&quot;</span></span>
<span class="line"><span>1) &quot;pmessage&quot;</span></span>
<span class="line"><span>2) &quot;b*&quot;</span></span>
<span class="line"><span>3) &quot;b11&quot;</span></span>
<span class="line"><span>4) &quot;m1&quot;</span></span>
<span class="line"><span>1) &quot;pmessage&quot;</span></span>
<span class="line"><span>2) &quot;d?*&quot;</span></span>
<span class="line"><span>3) &quot;d1&quot;</span></span>
<span class="line"><span>4) &quot;m1&quot;</span></span>
<span class="line"><span>1) &quot;pmessage&quot;</span></span>
<span class="line"><span>2) &quot;d?*&quot;</span></span>
<span class="line"><span>3) &quot;d11&quot;</span></span>
<span class="line"><span>4) &quot;m1&quot;</span></span></code></pre></div><ul><li><strong>注意点</strong></li></ul><p>(1)使用psubscribe命令可以重复订阅同一个频道，如客户端执行了<code>psubscribe c? c?*</code>。这时向c1发布消息客户端会接受到两条消息，而同时publish命令的返回值是2而不是1。同样的，如果有另一个客户端执行了<code>subscribe c1</code> 和<code>psubscribe c?*</code>的话，向c1发送一条消息该客户顿也会受到两条消息(但是是两种类型:message和pmessage)，同时publish命令也返回2.</p><p>(2)punsubscribe命令可以退订指定的规则，用法是: <code>punsubscribe [pattern [pattern ...]]</code>,如果没有参数则会退订所有规则。</p><p>(3)使用punsubscribe只能退订通过psubscribe命令订阅的规则，不会影响直接通过subscribe命令订阅的频道；同样unsubscribe命令也不会影响通过psubscribe命令订阅的规则。另外需要注意punsubscribe命令退订某个规则时不会将其中的通配符展开，而是进行严格的字符串匹配，所以<code>punsubscribe *</code> 无法退订<code>c*</code>规则，而是必须使用<code>punsubscribe c*</code>才可以退订。（它们是相互独立的，后文可以看到数据结构上看也是两种实现）</p><h2 id="深入理解" tabindex="-1">深入理解 <a class="header-anchor" href="#深入理解" aria-label="Permalink to &quot;深入理解&quot;">​</a></h2><blockquote><p>我们通过几个问题，来深入理解Redis的订阅发布机制</p></blockquote><h3 id="基于频道-channel-的发布-订阅如何实现的" tabindex="-1">基于频道(Channel)的发布/订阅如何实现的？ <a class="header-anchor" href="#基于频道-channel-的发布-订阅如何实现的" aria-label="Permalink to &quot;基于频道(Channel)的发布/订阅如何实现的？&quot;">​</a></h3><p>底层是通过字典（图中的pubsub_channels）实现的，这个字典就用于保存订阅频道的信息：字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p><ul><li><strong>数据结构</strong></li></ul><p>比如说，在下图展示的这个 pubsub_channels 示例中， client2 、 client5 和 client1 就订阅了 channel1 ， 而其他频道也分别被别的客户端所订阅：</p><p><img src="`+u+'" alt="error.图片加载失败"></p><ul><li><strong>订阅</strong></li></ul><p>当客户端调用 SUBSCRIBE 命令时， 程序就将客户端和要订阅的频道在 pubsub_channels 字典中关联起来。</p><p>举个例子，如果客户端 client10086 执行命令 <code>SUBSCRIBE channel1 channel2 channel3</code> ，那么前面展示的 pubsub_channels 将变成下面这个样子：</p><p><img src="'+b+`" alt="error.图片加载失败"></p><ul><li><strong>发布</strong></li></ul><p>当调用 <code>PUBLISH channel message</code> 命令， 程序首先根据 channel 定位到字典的键， 然后将信息发送给字典值链表中的所有客户端。</p><p>比如说，对于以下这个 pubsub_channels 实例， 如果某个客户端执行命令 <code>PUBLISH channel1 &quot;hello moto&quot;</code> ，那么 client2 、 client5 和 client1 三个客户端都将接收到 &quot;hello moto&quot; 信息：</p><ul><li><strong>退订</strong></li></ul><p>使用 UNSUBSCRIBE 命令可以退订指定的频道， 这个命令执行的是订阅的反操作： 它从 pubsub_channels 字典的给定频道（键）中， 删除关于当前客户端的信息， 这样被退订频道的信息就不会再发送给这个客户端。</p><h3 id="基于模式-pattern-的发布-订阅如何实现的" tabindex="-1">基于模式(Pattern)的发布/订阅如何实现的？ <a class="header-anchor" href="#基于模式-pattern-的发布-订阅如何实现的" aria-label="Permalink to &quot;基于模式(Pattern)的发布/订阅如何实现的？&quot;">​</a></h3><p>底层是pubsubPattern节点的链表。</p><ul><li><strong>数据结构</strong> redisServer.pubsub_patterns 属性是一个链表，链表中保存着所有和模式相关的信息：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct redisServer {</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>    list *pubsub_patterns;</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>};</span></span></code></pre></div><p>链表中的每个节点都包含一个 redis.h/pubsubPattern 结构：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typedef struct pubsubPattern {</span></span>
<span class="line"><span>    redisClient *client;</span></span>
<span class="line"><span>    robj *pattern;</span></span>
<span class="line"><span>} pubsubPattern;</span></span></code></pre></div><p>client 属性保存着订阅模式的客户端，而 pattern 属性则保存着被订阅的模式。</p><p>每当调用 PSUBSCRIBE 命令订阅一个模式时， 程序就创建一个包含客户端信息和被订阅模式的 pubsubPattern 结构， 并将该结构添加到 redisServer.pubsub_patterns 链表中。</p><p>作为例子，下图展示了一个包含两个模式的 pubsub_patterns 链表， 其中 client123 和 client256 都正在订阅 tweet.shop.* 模式：</p><p><img src="`+d+'" alt="error.图片加载失败"></p><ul><li><strong>订阅</strong></li></ul><p>如果这时客户端 client10086 执行 <code>PSUBSCRIBE broadcast.list.*</code> ， 那么 pubsub_patterns 链表将被更新成这样：</p><p><img src="'+h+`" alt="error.图片加载失败"></p><p>通过遍历整个 pubsub_patterns 链表，程序可以检查所有正在被订阅的模式，以及订阅这些模式的客户端。</p><ul><li><strong>发布</strong></li></ul><p>发送信息到模式的工作也是由 PUBLISH 命令进行的, 显然就是匹配模式获得Channels，然后再把消息发给客户端。</p><ul><li><strong>退订</strong></li></ul><p>使用 PUNSUBSCRIBE 命令可以退订指定的模式， 这个命令执行的是订阅模式的反操作： 程序会删除 redisServer.pubsub_patterns 链表中， 所有和被退订模式相关联的 pubsubPattern 结构， 这样客户端就不会再收到和模式相匹配的频道发来的信息。</p><h3 id="springboot结合redis发布-订阅实例" tabindex="-1">SpringBoot结合Redis发布/订阅实例？ <a class="header-anchor" href="#springboot结合redis发布-订阅实例" aria-label="Permalink to &quot;SpringBoot结合Redis发布/订阅实例？&quot;">​</a></h3><p>最佳实践是通过RedisTemplate，关键代码如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 发布</span></span>
<span class="line"><span>redisTemplate.convertAndSend(&quot;my_topic_name&quot;, &quot;message_content&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 配置订阅</span></span>
<span class="line"><span>RedisMessageListenerContainer container = new RedisMessageListenerContainer();</span></span>
<span class="line"><span>container.setConnectionFactory(connectionFactory);</span></span>
<span class="line"><span>container.addMessageListener(xxxMessageListenerAdapter, &quot;my_topic_name&quot;);</span></span></code></pre></div><p>我找了<a href="https://blog.csdn.net/llll234/article/details/80966952" target="_blank" rel="noreferrer">一篇文章在新窗口打开</a>，如果需要可以看看具体的集成。</p><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><ul><li><a href="https://redisbook.readthedocs.io/en/latest/feature/pubsub.html" target="_blank" rel="noreferrer">https://redisbook.readthedocs.io/en/latest/feature/pubsub.html</a></li><li><a href="https://www.cnblogs.com/qlqwjy/p/9763754.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/qlqwjy/p/9763754.html</a></li><li><a href="https://blog.csdn.net/ibigboy/article/details/95751542" target="_blank" rel="noreferrer">https://blog.csdn.net/ibigboy/article/details/95751542</a></li></ul><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>`,85)]))}const x=i(g,[["render",q]]);export{P as __pageData,x as default};
