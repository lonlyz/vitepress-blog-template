import{_ as s,c as e,ai as n,o as t}from"./chunks/framework.BrYByd3F.js";const u=JSON.parse('{"title":"MySQL - 性能优化","description":"","frontmatter":{},"headers":[],"relativePath":"db/sql-mysql/sql-mysql-performance.md","filePath":"db/sql-mysql/sql-mysql-performance.md","lastUpdated":1737706346000}'),l={name:"db/sql-mysql/sql-mysql-performance.md"};function i(p,a,o,r,d,c){return t(),e("div",null,a[0]||(a[0]=[n(`<h1 id="mysql-性能优化" tabindex="-1">MySQL - 性能优化 <a class="header-anchor" href="#mysql-性能优化" aria-label="Permalink to &quot;MySQL - 性能优化&quot;">​</a></h1><h2 id="使用-explain-进行分析" tabindex="-1">使用 Explain 进行分析 <a class="header-anchor" href="#使用-explain-进行分析" aria-label="Permalink to &quot;使用 Explain 进行分析&quot;">​</a></h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有:</p><h2 id="优化数据访问" tabindex="-1">优化数据访问 <a class="header-anchor" href="#优化数据访问" aria-label="Permalink to &quot;优化数据访问&quot;">​</a></h2><h3 id="_1-减少请求的数据量" tabindex="-1">1. 减少请求的数据量 <a class="header-anchor" href="#_1-减少请求的数据量" aria-label="Permalink to &quot;1\\. 减少请求的数据量&quot;">​</a></h3><ul><li>只返回必要的列: 最好不要使用 SELECT * 语句。</li><li>只返回必要的行: 使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h3 id="_2-减少服务器端扫描的行数" tabindex="-1">2. 减少服务器端扫描的行数 <a class="header-anchor" href="#_2-减少服务器端扫描的行数" aria-label="Permalink to &quot;2\\. 减少服务器端扫描的行数&quot;">​</a></h3><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="重构查询方式" tabindex="-1">重构查询方式 <a class="header-anchor" href="#重构查询方式" aria-label="Permalink to &quot;重构查询方式&quot;">​</a></h2><h3 id="_1-切分大查询" tabindex="-1">1. 切分大查询 <a class="header-anchor" href="#_1-切分大查询" aria-label="Permalink to &quot;1\\. 切分大查询&quot;">​</a></h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DELEFT FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>rows_affected = 0</span></span>
<span class="line"><span>do {</span></span>
<span class="line"><span>    rows_affected = do_query(</span></span>
<span class="line"><span>    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span></span>
<span class="line"><span>} while rows_affected &gt; 0</span></span></code></pre></div><h3 id="_2-分解大连接查询" tabindex="-1">2. 分解大连接查询 <a class="header-anchor" href="#_2-分解大连接查询" aria-label="Permalink to &quot;2\\. 分解大连接查询&quot;">​</a></h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有:</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM tab</span></span>
<span class="line"><span>JOIN tag_post ON tag_post.tag_id=tag.id</span></span>
<span class="line"><span>JOIN post ON tag_post.post_id=post.id</span></span>
<span class="line"><span>WHERE tag.tag=&#39;mysql&#39;;</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM tag WHERE tag=&#39;mysql&#39;;</span></span>
<span class="line"><span>SELECT * FROM tag_post WHERE tag_id=1234;</span></span>
<span class="line"><span>SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span></span></code></pre></div><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>`,20)]))}const _=s(l,[["render",i]]);export{u as __pageData,_ as default};
