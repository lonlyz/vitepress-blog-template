import{_ as d,c as e,ai as r,o as a}from"./chunks/framework.BrYByd3F.js";const o="/vitepress-blog-template/images/db/db-sql-x-1.png",n="/vitepress-blog-template/images/pics/c2d343f7-604c-4856-9a3c-c71d6f67fecc.png",m=JSON.parse('{"title":"SQL DB - 关系型数据库设计理论","description":"","frontmatter":{},"headers":[],"relativePath":"db/sql/sql-db-theory-concept.md","filePath":"db/sql/sql-db-theory-concept.md","lastUpdated":1737706346000}'),l={name:"db/sql/sql-db-theory-concept.md"};function p(i,t,s,h,g,b){return a(),e("div",null,t[0]||(t[0]=[r('<h1 id="sql-db-关系型数据库设计理论" tabindex="-1">SQL DB - 关系型数据库设计理论 <a class="header-anchor" href="#sql-db-关系型数据库设计理论" aria-label="Permalink to &quot;SQL DB - 关系型数据库设计理论&quot;">​</a></h1><blockquote><p>在上文了解数据库如何工作后，本节介绍如何将一个<strong>关系模型</strong>（基于表的数据模型）合理的转化为<strong>数据表</strong>和<strong>关系表</strong>，以及确定<strong>主外键</strong>的。这便是数据库设计理论基础，包括术语，函数依赖，范式等理论基础。@pdai</p></blockquote><h2 id="重要的术语" tabindex="-1">重要的术语 <a class="header-anchor" href="#重要的术语" aria-label="Permalink to &quot;重要的术语&quot;">​</a></h2><blockquote><p>关系模型是一种基于表的数据模型，以下为关系学生信息，该表有很多不足之处，本文研究内容就是如何改进它：</p></blockquote><p><img src="'+o+'" alt="error.图片加载失败"></p><p>下面是一些重要术语：</p><ul><li><p><strong>属性（attribute）</strong>：列的名字，上图有学号、姓名、班级、兴趣爱好、班主任、课程、授课主任、分数。</p></li><li><p><strong>依赖（relation）</strong>：列属性间存在的某种联系。</p></li><li><p><strong>元组（tuple）</strong>：每一个行，如第二行 （1301，小明，13班，篮球，王老师，英语，赵英，70） 就是一个元组</p></li><li><p><strong>表（table）</strong>：由多个属性，以及众多元组所表示的各个实例组成。</p></li><li><p><strong>模式（schema）</strong>：这里我们指逻辑结构，如 学生信息（学号，姓名，班级，兴趣爱好，班主任，课程，授课主任，分数） 的笼统表述。</p></li><li><p><strong>域（domain）</strong>：数据类型，如string、integer等，上图中每一个属性都有它的数据类型（即域）。</p></li><li><p><strong>键（key）</strong>：由关系的一个或多个属性组成，任意两个键相同的元组，所有属性都相同。需要保证表示键的属性最少。一个关系可以存在好几种键，工程中一般从这些候选键中选出一个作为<strong>主键（primary key）</strong>。</p></li><li><p><strong>候选键（candidate key）</strong>：由关系的一个或多个属性组成，候选键都具备键的特征，都有资格成为主键。</p></li><li><p><strong>超键（super key）</strong>：包含键的属性集合，无需保证属性集的最小化。每个键也是超键。可以认为是<strong>键的超集</strong>。</p></li><li><p><strong>外键（foreign key）</strong>：如果某一个关系A中的一个（组）属性是另一个关系B的键，则该（组）属性在A中称为外键。</p></li><li><p><strong>主属性（prime attribute）</strong>：所有候选键所包含的属性都是主属性。</p></li><li><p><strong>投影（projection）</strong>：选取特定的列，如将关系学生信息投影为学号、姓名即得到上表中仅包含学号、姓名的列</p></li><li><p><strong>选择（selection）</strong>：按照一定条件选取特定元组，如选择上表中分数&gt;80的元组。</p></li><li><p><strong>笛卡儿积（交叉连接Cross join）</strong>：第一个关系每一行分别与第二个关系的每一行组合。</p></li><li><p><strong>自然连接（natural join）</strong>：第一个关系中每一行与第二个关系的每一行进行匹配，如果得到有交叉部分则合并，若无交叉部分则舍弃。</p></li><li><p><strong>连接（theta join）</strong>：即加上约束条件的笛卡儿积，先得到笛卡儿积，然后根据约束条件删除不满足的元组。</p></li><li><p><strong>外连接（outer join）</strong>：执行自然连接后，将舍弃的部分也加入，并且匹配失败处的属性用NULL代替。</p></li><li><p><strong>除法运算（division）</strong>：关系R除以关系S的结果为T，则T包含所有在R但不在S中的属性，且T的元组与S的元组的所有组合在R中。</p></li></ul><h2 id="函数依赖" tabindex="-1">函数依赖 <a class="header-anchor" href="#函数依赖" aria-label="Permalink to &quot;函数依赖&quot;">​</a></h2><blockquote><p>通过函数依赖关系，来帮助你确定表中的合理主外键等；这里只是简介，有这么个概念就可以了，因为大多数情况你不用那些所谓的推倒关系，你也是可以凭借<strong>直觉</strong>设计出来的。</p></blockquote><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A&#39;，使得 A&#39;-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h2 id="异常" tabindex="-1">异常 <a class="header-anchor" href="#异常" aria-label="Permalink to &quot;异常&quot;">​</a></h2><blockquote><p>介绍 不符合范式的关系，会产生很多异常，为了引出<strong>范式</strong>的内容。</p></blockquote><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table tabindex="0"><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常:</p><ul><li>冗余数据: 例如 <code>学生-2</code> 出现了两次。</li><li>修改异常: 修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常: 删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常: 例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h2 id="范式" tabindex="-1">范式 <a class="header-anchor" href="#范式" aria-label="Permalink to &quot;范式&quot;">​</a></h2><blockquote><p>范式理论是为了解决以上提到四种异常。</p></blockquote><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><p><img src="'+n+'" alt="image"></p><h3 id="_1-第一范式-1nf" tabindex="-1">1. 第一范式 (1NF) <a class="header-anchor" href="#_1-第一范式-1nf" aria-label="Permalink to &quot;1\\. 第一范式 (1NF)&quot;">​</a></h3><p>属性不可分。</p><h3 id="_2-第二范式-2nf" tabindex="-1">2. 第二范式 (2NF) <a class="header-anchor" href="#_2-第二范式-2nf" aria-label="Permalink to &quot;2\\. 第二范式 (2NF)&quot;">​</a></h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><strong>分解前</strong></p><table tabindex="0"><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖:</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><strong>分解后</strong></p><p>关系-1</p><table tabindex="0"><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td></tr></tbody></table><p>有以下函数依赖:</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table tabindex="0"><thead><tr><th>Sno</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>课程-2</td><td>95</td></tr></tbody></table><p>有以下函数依赖:</p><ul><li>Sno, Cname -&gt; Grade</li></ul><h3 id="_3-第三范式-3nf" tabindex="-1">3. 第三范式 (3NF) <a class="header-anchor" href="#_3-第三范式-3nf" aria-label="Permalink to &quot;3\\. 第三范式 (3NF)&quot;">​</a></h3><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖:</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解:</p><p>关系-11</p><table tabindex="0"><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td></tr></tbody></table><p>关系-12</p><table tabindex="0"><thead><tr><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>学院-1</td><td>院长-1</td></tr><tr><td>学院-2</td><td>院长-2</td></tr></tbody></table><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><p>这里还有一篇<a href="https://blog.csdn.net/calcular/article/details/79332453" target="_blank" rel="noreferrer">文章在新窗口打开</a>讲的挺详细的可以看下。</p><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',55)]))}const u=d(l,[["render",p]]);export{m as __pageData,u as default};
