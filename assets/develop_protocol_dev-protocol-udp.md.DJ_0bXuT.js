import{_ as e,c as r,ai as l,o}from"./chunks/framework.BrYByd3F.js";const a="/vitepress-blog-template/images/develop/network/dev-network-udp-1.png",p="/vitepress-blog-template/images/develop/network/dev-network-udp-2.png",i="/vitepress-blog-template/images/develop/network/dev-network-udp-3.png",u=JSON.parse('{"title":"网络协议 - UDP 协议详解","description":"","frontmatter":{},"headers":[],"relativePath":"develop/protocol/dev-protocol-udp.md","filePath":"develop/protocol/dev-protocol-udp.md","lastUpdated":1737706346000}'),n={name:"develop/protocol/dev-protocol-udp.md"};function s(P,t,d,c,D,U){return o(),r("div",null,t[0]||(t[0]=[l('<h1 id="网络协议-udp-协议详解" tabindex="-1">网络协议 - UDP 协议详解 <a class="header-anchor" href="#网络协议-udp-协议详解" aria-label="Permalink to &quot;网络协议 - UDP 协议详解&quot;">​</a></h1><blockquote><p>基于TCP和UDP的协议非常广泛，所以也有必要对UDP协议进行详解。@pdai</p></blockquote><h2 id="udp概述" tabindex="-1">UDP概述 <a class="header-anchor" href="#udp概述" aria-label="Permalink to &quot;UDP概述&quot;">​</a></h2><p>UDP(User Datagram Protocol)即用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。UDP协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天UDP仍然不失为一项非常实用和可行的网络传输层协议。UDP报文没有可靠性保证、顺序保证和流量控制字段等，可靠性较差。但是正因为UDP协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。</p><h2 id="udp特点" tabindex="-1">UDP特点 <a class="header-anchor" href="#udp特点" aria-label="Permalink to &quot;UDP特点&quot;">​</a></h2><p>UDP提供不可靠服务，具有TCP所没有的优势：</p><ul><li><p><strong>UDP无连接</strong>，时间上不存在建立连接需要的时延。空间上，TCP需要在端系统中维护连接状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。 举个例子：</p><ul><li>DNS如果运行在TCP之上而不是UDP，那么DNS的速度将会慢很多。</li><li>HTTP使用TCP而不是UDP，是因为对于基于文本数据的Web网页来说，可靠性很重要。</li><li>同一种专用应用服务器在支持UDP时，一定能支持更多的活动客户机。</li></ul></li><li><p><strong>分组首部开销小</strong>，TCP首部20字节，UDP首部8字节。</p></li><li><p><strong>UDP没有拥塞控制</strong>，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，能容 忍一些数据的丢失，但是不能允许有较大的时延（比如实时视频，直播等）</p></li><li><p><strong>UDP提供尽最大努力的交付，不保证可靠交付</strong>。所有维护传输可靠性的工作需要用户在应用层来完成。没有TCP的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息</p></li><li><p><strong>UDP是面向报文的</strong>，对应用层交下来的报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是UDP数据报处理的最小单位。 正是因为这样，UDP显得不够灵活，不能控制读写数据的次数和数量。比如我们要发送100个字节的报文，我们调用一次sendto函数就会发送100字节，对端也需要用recvfrom函数一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。</p></li><li><p><strong>UDP常用一次性传输比较少量数据的网络应用</strong>，如DNS,SNMP等，因为对于这些应用，若是采用TCP，为连接的创建，维护和拆除带来不小的开销。UDP也常用于多媒体应用（如IP电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP的拥塞控制会使他们有较大的延迟，也是不可容忍的</p></li><li><p><strong>UDP 支持一对一、一对多、多对一和多对多的交互通信</strong>。</p></li></ul><p>还要注意的是：</p><ul><li>IP 数据报要经过互连网中许多路由器的存储转发；UDP 用户数据报是在<strong>运输层的端到端抽象的逻辑信道中传送</strong>的。</li></ul><p><strong>UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文</strong>。</p><p><img src="'+a+'" alt="error.图片加载失败"></p><h2 id="udp的首部格式" tabindex="-1">UDP的首部格式 <a class="header-anchor" href="#udp的首部格式" aria-label="Permalink to &quot;UDP的首部格式&quot;">​</a></h2><p>在计算检验和时，<strong>临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。</strong></p><p><img src="'+p+'" alt="error.图片加载失败"></p><ul><li><strong>源端口</strong>: 占16位、源端口号。在需要对方回信时选用。不需要时可用全0。</li><li><strong>目的端口</strong>: 占16位、目的端口号。这在终点交付报文时必须使用。</li><li><strong>长度</strong>: 占16位、UDP用户数据报的长度,其最小值是8(仅有首部)。</li><li><strong>检验和</strong>: 占16位、检测UDP用户数据报在传输中是否有错。有错就丢弃。</li></ul><p>请注意，虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字。</p><h3 id="udp校验" tabindex="-1">UDP校验 <a class="header-anchor" href="#udp校验" aria-label="Permalink to &quot;UDP校验&quot;">​</a></h3><blockquote><p>UDP校验和的计算方法和IP数据报首部校验和的计算方法相似，都<strong>使用二进制反码运算求和再取反</strong>，但不同的是：<strong>IP数据报的校验和之检验IP数据报和首部，但UDP的校验和是把首部和数据部分一起校验</strong>。</p></blockquote><p>发送方，首先是把全零放入校验和字段并且添加伪首部，然后把UDP数据报看成是由许多16位的子串连接起来，若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾增加一个全零字节（此字节不发送），接下来就按照二进制反码计算出这些16位字的和。将此和的二进制反码写入校验和字段。在接收方，把收到得UDP数据报加上伪首部（如果不为偶数个字节，还需要补上全零字节）后，按二进制反码计算出这些16位字的和。当无差错时其结果全为1,。否则就表明有差错出现，接收方应该丢弃这个UDP数据报。</p><p>下图是计算UDP校验和的例子：</p><p><img src="'+i+'" alt="error.图片加载失败"></p><p>注意：</p><ul><li>校验时，若UDP数据报部分的长度不是偶数个字节，则需要填入一个全0字节，但是次字节和伪首部一样，是不发送的。</li><li>如果UDP校验和校验出UDP数据报是错误的，可以丢弃，也可以交付上层，但是要附上错误报告，告诉上层这是错误的数据报。</li><li>通过伪首部，不仅可以检查源端口号，目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址。 这种差错检验的检错能力不强，但是简单，速度快。</li></ul><h2 id="參考文章" tabindex="-1">參考文章 <a class="header-anchor" href="#參考文章" aria-label="Permalink to &quot;參考文章&quot;">​</a></h2><ul><li><a href="https://blog.csdn.net/dog250/article/details/6896949" target="_blank" rel="noreferrer">https://blog.csdn.net/dog250/article/details/6896949</a></li><li><a href="https://blog.csdn.net/qq%5C_42196196/article/details/83956689" target="_blank" rel="noreferrer">https://blog.csdn.net/qq\\_42196196/article/details/83956689</a></li><li><a href="https://cloud.tencent.com/developer/article/1004554" target="_blank" rel="noreferrer">https://cloud.tencent.com/developer/article/1004554</a></li><li><a href="https://blog.csdn.net/aa1928992772/article/details/85240358" target="_blank" rel="noreferrer">https://blog.csdn.net/aa1928992772/article/details/85240358</a></li></ul><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',26)]))}const h=e(n,[["render",s]]);export{u as __pageData,h as default};
