import{_ as n,c as a,ai as p,o as e}from"./chunks/framework.BrYByd3F.js";const l="/vitepress-blog-template/images/develop/ut/ut-dev-mock-4.png",t="/vitepress-blog-template/images/develop/ut/ut-dev-mock-5.png",i="/vitepress-blog-template/images/develop/ut/dev-ut-mock-1.png",c="/vitepress-blog-template/images/develop/ut/dev-ut-mock-11.png",o="/vitepress-blog-template/images/develop/ut/dev-ut-mock-12.png",b=JSON.parse('{"title":"单元测试 - Mockito 详解","description":"","frontmatter":{},"headers":[],"relativePath":"develop/ut/dev-ut-x-mockito.md","filePath":"develop/ut/dev-ut-x-mockito.md","lastUpdated":1737706346000}'),r={name:"develop/ut/dev-ut-x-mockito.md"};function d(m,s,u,k,h,g){return e(),a("div",null,s[0]||(s[0]=[p('<h1 id="单元测试-mockito-详解" tabindex="-1">单元测试 - Mockito 详解 <a class="header-anchor" href="#单元测试-mockito-详解" aria-label="Permalink to &quot;单元测试 - Mockito 详解&quot;">​</a></h1><blockquote><p>Mock通常是指，在测试一个对象A时，我们构造一些假的对象来模拟与A之间的交互，而这些Mock对象的行为是我们事先设定且符合预期。通过这些Mock对象来测试A在正常逻辑，异常逻辑或压力情况下工作是否正常。而Mockito是最流行的Java mock框架之一。@pdai</p></blockquote><h2 id="什么是-mock-测试" tabindex="-1">什么是 Mock 测试 <a class="header-anchor" href="#什么是-mock-测试" aria-label="Permalink to &quot;什么是 Mock 测试&quot;">​</a></h2><blockquote><p>Mock通常是指，在测试一个对象A时，我们构造一些假的对象来模拟与A之间的交互，而这些Mock对象的行为是我们事先设定且符合预期。通过这些Mock对象来测试A在正常逻辑，异常逻辑或压力情况下工作是否正常。@pdai</p></blockquote><p>Mock 测试就是在测试过程中，对于某些不容易构造（如 HttpServletRequest 必须在Servlet 容器中才能构造出来）或者不容易获取比较复杂的对象（如 JDBC 中的ResultSet 对象），用一个虚拟的对象（Mock 对象）来创建以便测试的测试方法。Mock 最大的功能是帮你把单元测试的耦合分解开，如果你的代码对另一个类或者接口有依赖，它能够帮你模拟这些依赖，并帮你验证所调用的依赖的行为。</p><p>先来看看下面这个示例：</p><p><img src="'+l+'" alt="error.图片加载失败"></p><p>从上图可以看出如果我们要对A进行测试，那么就要先把整个依赖树构建出来，也就是BCDE的实例。</p><p>一种替代方案就是使用mocks</p><p><img src="'+t+`" alt="error.图片加载失败"></p><p>从图中可以清晰的看出, mock对象就是在调试期间用来作为真实对象的替代品。</p><p>mock测试就是在测试过程中，对那些不容易构建的对象用一个虚拟对象来代替测试的方法就叫mock测试。</p><h2 id="mock-适用在什么场景" tabindex="-1">Mock 适用在什么场景 <a class="header-anchor" href="#mock-适用在什么场景" aria-label="Permalink to &quot;Mock 适用在什么场景&quot;">​</a></h2><blockquote><p>在使用Mock的过程中，发现Mock是有一些通用性的，对于一些应用场景，是非常适合使用Mock的：</p></blockquote><ul><li>真实对象具有不可确定的行为(产生不可预测的结果，如股票的行情)</li><li>真实对象很难被创建(比如具体的web容器)</li><li>真实对象的某些行为很难触发(比如网络错误)</li><li>真实情况令程序的运行速度很慢</li><li>真实对象有用户界面</li><li>测试需要询问真实对象它是如何被调用的(比如测试可能需要验证某个回调函数是否被调用了)</li><li>真实对象实际上并不存在(当需要和其他开发小组，或者新的硬件系统打交道的时候，这是一个普遍的问题)</li></ul><p>当然，也有一些不得不Mock的场景：</p><ul><li>一些比较难构造的Object：这类Object通常有很多依赖，在单元测试中构造出这样类通常花费的成本太大。</li><li>执行操作的时间较长Object：有一些Object的操作费时，而被测对象依赖于这一个操作的执行结果，例如大文件写操作，数据的更新等等，出于测试的需求，通常将这类操作进行Mock。</li><li>异常逻辑：一些异常的逻辑往往在正常测试中是很难触发的，通过Mock可以人为的控制触发异常逻辑。</li></ul><p>在一些压力测试的场景下，也不得不使用Mock，例如在分布式系统测试中，通常需要测试一些单点（如namenode，jobtracker）在压力场景下的工作是否正常。而通常测试集群在正常逻辑下无法提供足够的压力（主要原因是受限于机器数量），这时候就需要应用Mock去满足。</p><h2 id="mockito" tabindex="-1">Mockito <a class="header-anchor" href="#mockito" aria-label="Permalink to &quot;Mockito&quot;">​</a></h2><blockquote><p>Mockito是最流行的Java mock框架之一.</p></blockquote><h3 id="官方资料" tabindex="-1">官方资料 <a class="header-anchor" href="#官方资料" aria-label="Permalink to &quot;官方资料&quot;">​</a></h3><ul><li>Mockito 官方网站</li></ul><p><a href="https://site.mockito.org/" target="_blank" rel="noreferrer">https://site.mockito.org/</a></p><ul><li>PowerMockito Github</li></ul><p><a href="https://github.com/powermock/powermock/" target="_blank" rel="noreferrer">https://github.com/powermock/powermock/</a></p><h3 id="maven包引入" tabindex="-1">Maven包引入 <a class="header-anchor" href="#maven包引入" aria-label="Permalink to &quot;Maven包引入&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span>
<span class="line"><span>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="line"><span>         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="line"><span>         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span></span>
<span class="line"><span>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    &lt;groupId&gt;pdai.tech&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;java-mockito&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span></span>
<span class="line"><span>    &lt;dependencies&gt;</span></span>
<span class="line"><span>        &lt;dependency&gt;</span></span>
<span class="line"><span>            &lt;groupId&gt;junit&lt;/groupId&gt;</span></span>
<span class="line"><span>            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span></span>
<span class="line"><span>            &lt;version&gt;4.12&lt;/version&gt;</span></span>
<span class="line"><span>            &lt;scope&gt;test&lt;/scope&gt;</span></span>
<span class="line"><span>        &lt;/dependency&gt;</span></span>
<span class="line"><span>        &lt;!-- https://mvnrepository.com/artifact/org.mockito/mockito-core --&gt;</span></span>
<span class="line"><span>        &lt;dependency&gt;</span></span>
<span class="line"><span>            &lt;groupId&gt;org.mockito&lt;/groupId&gt;</span></span>
<span class="line"><span>            &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;</span></span>
<span class="line"><span>            &lt;version&gt;3.7.7&lt;/version&gt;</span></span>
<span class="line"><span>            &lt;scope&gt;test&lt;/scope&gt;</span></span>
<span class="line"><span>        &lt;/dependency&gt;</span></span>
<span class="line"><span>    &lt;/dependencies&gt;</span></span>
<span class="line"><span>&lt;/project&gt;</span></span></code></pre></div><h3 id="测试-hello-world" tabindex="-1">测试:Hello World <a class="header-anchor" href="#测试-hello-world" aria-label="Permalink to &quot;测试:Hello World&quot;">​</a></h3><blockquote><p>本例子主要用来测试DemoService类，但是DemoService又依赖于DemoDao，这时候我们便可以mock出DemoDao的返回预期值，从而测试DemoService类。</p></blockquote><p>待测试类DemoService</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>package tech.pdai.mockito.service;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import tech.pdai.mockito.dao.DemoDao;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class DemoService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private DemoDao demoDao;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public DemoService(DemoDao demoDao) {</span></span>
<span class="line"><span>        this.demoDao = demoDao;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public int getDemoStatus(){</span></span>
<span class="line"><span>        return demoDao.getDemoStatus();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>依赖DemoDao</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>package tech.pdai.mockito.dao;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import java.util.Random;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class DemoDao {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public int getDemoStatus(){</span></span>
<span class="line"><span>        return new Random().nextInt();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>测试类</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>package tech.pdai.mockito;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import org.junit.Assert;</span></span>
<span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span>import org.mockito.Mockito;</span></span>
<span class="line"><span>import tech.pdai.mockito.dao.DemoDao;</span></span>
<span class="line"><span>import tech.pdai.mockito.service.DemoService;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * Hello World Test.</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>public class HelloWorldTest {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void helloWorldTest() {</span></span>
<span class="line"><span>        // mock DemoDao instance</span></span>
<span class="line"><span>        DemoDao mockDemoDao = Mockito.mock(DemoDao.class);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 使用 mockito 对 getDemoStatus 方法打桩</span></span>
<span class="line"><span>        Mockito.when(mockDemoDao.getDemoStatus()).thenReturn(1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 调用 mock 对象的 getDemoStatus 方法，结果永远是 1</span></span>
<span class="line"><span>        Assert.assertEquals(1, mockDemoDao.getDemoStatus());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // mock DemoService</span></span>
<span class="line"><span>        DemoService mockDemoService = new DemoService(mockDemoDao);</span></span>
<span class="line"><span>        Assert.assertEquals(1, mockDemoService.getDemoStatus() );</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>执行结果</p><p><img src="`+i+`" alt="error.图片加载失败"></p><h3 id="测试-使用mock方法" tabindex="-1">测试:使用mock方法 <a class="header-anchor" href="#测试-使用mock方法" aria-label="Permalink to &quot;测试:使用mock方法&quot;">​</a></h3><p>包含两块测试：一个是类测试，一个接口测试，具体如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>package tech.pdai.mockito;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import org.junit.Assert;</span></span>
<span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import java.util.List;</span></span>
<span class="line"><span>import java.util.Random;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import static org.mockito.Mockito.mock;</span></span>
<span class="line"><span>import static org.mockito.Mockito.when;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * Mock Class Test.</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>public class MockClassTest {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void mockClassTest() {</span></span>
<span class="line"><span>        Random mockRandom = mock(Random.class);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 默认值: mock 对象的方法的返回值默认都是返回类型的默认值</span></span>
<span class="line"><span>        System.out.println(mockRandom.nextBoolean()); // false</span></span>
<span class="line"><span>        System.out.println(mockRandom.nextInt()); // 0</span></span>
<span class="line"><span>        System.out.println(mockRandom.nextDouble()); // 0.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // mock: 指定调用 nextInt 方法时，永远返回 100</span></span>
<span class="line"><span>        when(mockRandom.nextInt()).thenReturn(100);</span></span>
<span class="line"><span>        Assert.assertEquals(100, mockRandom.nextInt());</span></span>
<span class="line"><span>        Assert.assertEquals(100, mockRandom.nextInt());</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void mockInterfaceTest() {</span></span>
<span class="line"><span>        List mockList = mock(List.class);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 接口的默认值：和类方法一致，都是默认返回值</span></span>
<span class="line"><span>        Assert.assertEquals(0, mockList.size());</span></span>
<span class="line"><span>        Assert.assertEquals(null, mockList.get(0));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 注意：调用 mock 对象的写方法，是没有效果的</span></span>
<span class="line"><span>        mockList.add(&quot;a&quot;);</span></span>
<span class="line"><span>        Assert.assertEquals(0, mockList.size());      // 没有指定 size() 方法返回值，这里结果是默认值</span></span>
<span class="line"><span>        Assert.assertEquals(null, mockList.get(0));   // 没有指定 get(0) 返回值，这里结果是默认值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // mock值测试</span></span>
<span class="line"><span>        when(mockList.get(0)).thenReturn(&quot;a&quot;);          // 指定 get(0)时返回 a</span></span>
<span class="line"><span>        Assert.assertEquals(0, mockList.size());        // 没有指定 size() 方法返回值，这里结果是默认值</span></span>
<span class="line"><span>        Assert.assertEquals(&quot;a&quot;, mockList.get(0));      // 因为上面指定了 get(0) 返回 a，所以这里会返回 a</span></span>
<span class="line"><span>        Assert.assertEquals(null, mockList.get(1));     // 没有指定 get(1) 返回值，这里结果是默认值</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>执行结果</p><p><img src="`+c+`" alt="error.图片加载失败"></p><h3 id="测试-适用-mock注解" tabindex="-1">测试:适用@Mock注解 <a class="header-anchor" href="#测试-适用-mock注解" aria-label="Permalink to &quot;测试:适用@Mock注解&quot;">​</a></h3><blockquote><p>@Mock 注解可以理解为对 mock 方法的一个替代。</p></blockquote><p>使用该注解时，要使用MockitoAnnotations.initMocks 方法，让注解生效, 比如放在@Before方法中初始化。</p><p>比较优雅优雅的写法是用MockitoJUnitRunner，它可以自动执行MockitoAnnotations.initMocks 方法。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>package tech.pdai.mockito;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import org.junit.Assert;</span></span>
<span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span>import org.junit.runner.RunWith;</span></span>
<span class="line"><span>import org.mockito.Mock;</span></span>
<span class="line"><span>import org.mockito.junit.MockitoJUnitRunner;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import java.util.Random;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import static org.mockito.Mockito.when;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * Mock Annotation</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>@RunWith(MockitoJUnitRunner.class)</span></span>
<span class="line"><span>public class MockAnnotationTest {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Mock</span></span>
<span class="line"><span>    private Random random;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test() {</span></span>
<span class="line"><span>        when(random.nextInt()).thenReturn(100);</span></span>
<span class="line"><span>        Assert.assertEquals(100, random.nextInt());</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="测试-参数匹配" tabindex="-1">测试:参数匹配 <a class="header-anchor" href="#测试-参数匹配" aria-label="Permalink to &quot;测试:参数匹配&quot;">​</a></h3><p>如果参数匹配既申明了精确匹配，也声明了模糊匹配；又或者同一个值的精确匹配出现了两次，使用时会匹配符合匹配条件的最新声明的匹配。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>package tech.pdai.mockito;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import org.junit.Assert;</span></span>
<span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span>import org.junit.runner.RunWith;</span></span>
<span class="line"><span>import org.mockito.Mock;</span></span>
<span class="line"><span>import org.mockito.junit.MockitoJUnitRunner;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import java.util.List;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import static org.mockito.ArgumentMatchers.anyInt;</span></span>
<span class="line"><span>import static org.mockito.Mockito.when;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * Mock Parameter Test.</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>@RunWith(MockitoJUnitRunner.class)</span></span>
<span class="line"><span>public class ParameterTest {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Mock</span></span>
<span class="line"><span>    private List&lt;String&gt; testList;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test01() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 精确匹配 0</span></span>
<span class="line"><span>        when(testList.get(0)).thenReturn(&quot;a&quot;);</span></span>
<span class="line"><span>        Assert.assertEquals(&quot;a&quot;, testList.get(0));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 精确匹配 0</span></span>
<span class="line"><span>        when(testList.get(0)).thenReturn(&quot;b&quot;);</span></span>
<span class="line"><span>        Assert.assertEquals(&quot;b&quot;, testList.get(0));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 模糊匹配</span></span>
<span class="line"><span>        when(testList.get(anyInt())).thenReturn(&quot;c&quot;);</span></span>
<span class="line"><span>        Assert.assertEquals(&quot;c&quot;, testList.get(0));</span></span>
<span class="line"><span>        Assert.assertEquals(&quot;c&quot;, testList.get(1));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>anyInt 只是用来匹配参数的工具之一，目前 mockito 有多种匹配函数，部分如下：</p><table tabindex="0"><thead><tr><th>函数名</th><th>匹配类型</th></tr></thead><tbody><tr><td>any()</td><td>所有对象类型</td></tr><tr><td>anyInt()</td><td>基本类型 int、非 null 的 Integer 类型</td></tr><tr><td>anyChar()</td><td>基本类型 char、非 null 的 Character 类型</td></tr><tr><td>anyShort()</td><td>基本类型 short、非 null 的 Short 类型</td></tr><tr><td>anyBoolean()</td><td>基本类型 boolean、非 null 的 Boolean 类型</td></tr><tr><td>anyDouble()</td><td>基本类型 double、非 null 的 Double 类型</td></tr><tr><td>anyFloat()</td><td>基本类型 float、非 null 的 Float 类型</td></tr><tr><td>anyLong()</td><td>基本类型 long、非 null 的 Long 类型</td></tr><tr><td>anyByte()</td><td>基本类型 byte、非 null 的 Byte 类型</td></tr><tr><td>anyString()</td><td>String 类型(不能是 null)</td></tr><tr><td>anyList()</td><td><code>List&lt;T&gt;</code> 类型(不能是 null)</td></tr><tr><td>anyMap()</td><td><code>Map&lt;K, V&gt;</code>类型(不能是 null)</td></tr><tr><td>anyCollection()</td><td><code>Collection&lt;T&gt;</code>类型(不能是 null)</td></tr><tr><td>anySet()</td><td><code>Set&lt;T&gt;</code>类型(不能是 null)</td></tr><tr><td>any(<code>Class&lt;T&gt;</code> type)</td><td>type类型的对象(不能是 null)</td></tr><tr><td>isNull()</td><td>null</td></tr><tr><td>notNull()</td><td>非 null</td></tr><tr><td>isNotNull()</td><td>非 null</td></tr></tbody></table><h3 id="测试-mock异常" tabindex="-1">测试:Mock异常 <a class="header-anchor" href="#测试-mock异常" aria-label="Permalink to &quot;测试:Mock异常&quot;">​</a></h3><blockquote><p>Mockito 使用 thenThrow 让方法抛出异常</p></blockquote><p>如下代码中，包含两个例子：一个是单个异常，一个是多个异常。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>package tech.pdai.mockito;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import org.junit.Assert;</span></span>
<span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import java.util.Random;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import static org.mockito.Mockito.mock;</span></span>
<span class="line"><span>import static org.mockito.Mockito.when;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * Exception Test.</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>public class ThrowTest {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 例子1： thenThrow 用来让函数调用抛出异常.</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void throwTest1() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Random mockRandom = mock(Random.class);</span></span>
<span class="line"><span>        when(mockRandom.nextInt()).thenThrow(new RuntimeException(&quot;异常&quot;));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            mockRandom.nextInt();</span></span>
<span class="line"><span>            Assert.fail();  // 上面会抛出异常，所以不会走到这里</span></span>
<span class="line"><span>        } catch (Exception ex) {</span></span>
<span class="line"><span>            Assert.assertTrue(ex instanceof RuntimeException);</span></span>
<span class="line"><span>            Assert.assertEquals(&quot;异常&quot;, ex.getMessage());</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * thenThrow 中可以指定多个异常。在调用时异常依次出现。若调用次数超过异常的数量，再次调用时抛出最后一个异常。</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void throwTest2() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Random mockRandom = mock(Random.class);</span></span>
<span class="line"><span>        when(mockRandom.nextInt()).thenThrow(new RuntimeException(&quot;异常1&quot;), new RuntimeException(&quot;异常2&quot;));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            mockRandom.nextInt();</span></span>
<span class="line"><span>            Assert.fail();</span></span>
<span class="line"><span>        } catch (Exception ex) {</span></span>
<span class="line"><span>            Assert.assertTrue(ex instanceof RuntimeException);</span></span>
<span class="line"><span>            Assert.assertEquals(&quot;异常1&quot;, ex.getMessage());</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            mockRandom.nextInt();</span></span>
<span class="line"><span>            Assert.fail();</span></span>
<span class="line"><span>        } catch (Exception ex) {</span></span>
<span class="line"><span>            Assert.assertTrue(ex instanceof RuntimeException);</span></span>
<span class="line"><span>            Assert.assertEquals(&quot;异常2&quot;, ex.getMessage());</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>执行结果</p><p><img src="`+o+`" alt="error.图片加载失败"></p><blockquote><p>对应返回类型是 void 的函数，thenThrow 是无效的，要使用 doThrow。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>package tech.pdai.mockito;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import org.junit.Assert;</span></span>
<span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span>import org.junit.runner.RunWith;</span></span>
<span class="line"><span>import org.mockito.Mock;</span></span>
<span class="line"><span>import org.mockito.MockitoAnnotations;</span></span>
<span class="line"><span>import org.mockito.junit.MockitoJUnitRunner;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import static org.mockito.Mockito.doThrow;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * Do Throw for void return.</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>@RunWith(MockitoJUnitRunner.class)</span></span>
<span class="line"><span>public class DoThrowTest {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    static class ExampleService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        public void hello() {</span></span>
<span class="line"><span>            System.out.println(&quot;Hello&quot;);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Mock</span></span>
<span class="line"><span>    private ExampleService exampleService;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 这种写法可以达到效果</span></span>
<span class="line"><span>        doThrow(new RuntimeException(&quot;异常&quot;)).when(exampleService).hello();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            exampleService.hello();</span></span>
<span class="line"><span>            Assert.fail();</span></span>
<span class="line"><span>        } catch (RuntimeException ex) {</span></span>
<span class="line"><span>            Assert.assertEquals(&quot;异常&quot;, ex.getMessage());</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>此外还有，可以查看官方文档</p><ul><li>doAnswer(Answer)</li><li>doNothing()</li><li>doCallRealMethod()</li></ul><h3 id="测试-spy-和-spy-注解" tabindex="-1">测试:spy 和 @Spy 注解 <a class="header-anchor" href="#测试-spy-和-spy-注解" aria-label="Permalink to &quot;测试:spy 和 @Spy 注解&quot;">​</a></h3><p>spy 和 mock不同，不同点是：</p><ul><li>spy 的参数是对象示例，mock 的参数是 class。</li><li>被 spy 的对象，调用其方法时默认会走真实方法。mock 对象不会。</li></ul><p>下面是一个对比：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import org.junit.Assert;</span></span>
<span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span>import static org.mockito.Mockito.*;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class ExampleService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    int add(int a, int b) {</span></span>
<span class="line"><span>        return a+b;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class MockitoDemo {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 测试 spy</span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test_spy() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        ExampleService spyExampleService = spy(new ExampleService());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 默认会走真实方法</span></span>
<span class="line"><span>        Assert.assertEquals(3, spyExampleService.add(1, 2));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 打桩后，不会走了</span></span>
<span class="line"><span>        when(spyExampleService.add(1, 2)).thenReturn(10);</span></span>
<span class="line"><span>        Assert.assertEquals(10, spyExampleService.add(1, 2));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 但是参数比匹配的调用，依然走真实方法</span></span>
<span class="line"><span>        Assert.assertEquals(3, spyExampleService.add(2, 1));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 测试 mock</span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test_mock() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        ExampleService mockExampleService = mock(ExampleService.class);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 默认返回结果是返回类型int的默认值</span></span>
<span class="line"><span>        Assert.assertEquals(0, mockExampleService.add(1, 2));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><p>spy 对应注解 @Spy，和 @Mock 是一样用的。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import org.junit.Assert;</span></span>
<span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span>import org.mockito.MockitoAnnotations;</span></span>
<span class="line"><span>import org.mockito.Spy;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import static org.mockito.Mockito.*;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class ExampleService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    int add(int a, int b) {</span></span>
<span class="line"><span>        return a+b;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class MockitoDemo {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Spy</span></span>
<span class="line"><span>    private ExampleService spyExampleService;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test_spy() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        MockitoAnnotations.initMocks(this);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Assert.assertEquals(3, spyExampleService.add(1, 2));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        when(spyExampleService.add(1, 2)).thenReturn(10);</span></span>
<span class="line"><span>        Assert.assertEquals(10, spyExampleService.add(1, 2));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><p>对于@Spy，如果发现修饰的变量是 null，会自动调用类的无参构造函数来初始化。</p><p>所以下面两种写法是等价的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 写法1</span></span>
<span class="line"><span>@Spy</span></span>
<span class="line"><span>private ExampleService spyExampleService;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 写法2</span></span>
<span class="line"><span>@Spy</span></span>
<span class="line"><span>private ExampleService spyExampleService = new ExampleService();</span></span></code></pre></div><p>如果没有无参构造函数，必须使用写法2。例子：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import org.junit.Assert;</span></span>
<span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span>import org.mockito.MockitoAnnotations;</span></span>
<span class="line"><span>import org.mockito.Spy;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class ExampleService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private int a;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public ExampleService(int a) {</span></span>
<span class="line"><span>        this.a = a;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    int add(int b) {</span></span>
<span class="line"><span>        return a+b;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class MockitoDemo {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Spy</span></span>
<span class="line"><span>    private ExampleService spyExampleService = new ExampleService(1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test_spy() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        MockitoAnnotations.initMocks(this);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Assert.assertEquals(3, spyExampleService.add(2));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="测试-测试隔离" tabindex="-1">测试:测试隔离 <a class="header-anchor" href="#测试-测试隔离" aria-label="Permalink to &quot;测试:测试隔离&quot;">​</a></h3><blockquote><p>根据 JUnit 单测隔离 ，当 Mockito 和 JUnit 配合使用时，也会将非static变量或者非单例隔离开。</p></blockquote><p>比如使用 @Mock 修饰的 mock 对象在不同的单测中会被隔离开。</p><p>示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span>import org.junit.runner.RunWith;</span></span>
<span class="line"><span>import org.mockito.Mock;</span></span>
<span class="line"><span>import org.mockito.junit.MockitoJUnitRunner;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import static org.mockito.Mockito.*;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@RunWith(MockitoJUnitRunner.class)</span></span>
<span class="line"><span>public class MockitoDemo {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    static class ExampleService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        public int add(int a, int b) {</span></span>
<span class="line"><span>            return a+b;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Mock</span></span>
<span class="line"><span>    private ExampleService exampleService;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test01() {</span></span>
<span class="line"><span>        System.out.println(&quot;---call test01---&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        System.out.println(&quot;打桩前: &quot; + exampleService.add(1, 2));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        when(exampleService.add(1, 2)).thenReturn(100);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        System.out.println(&quot;打桩后: &quot; + exampleService.add(1, 2));</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test02() {</span></span>
<span class="line"><span>        System.out.println(&quot;---call test02---&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        System.out.println(&quot;打桩前: &quot; + exampleService.add(1, 2));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        when(exampleService.add(1, 2)).thenReturn(100);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        System.out.println(&quot;打桩后: &quot; + exampleService.add(1, 2));</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><p>将两个单测一起运行，运行结果是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>---call test01---</span></span>
<span class="line"><span>打桩前: 0</span></span>
<span class="line"><span>打桩后: 100</span></span>
<span class="line"><span>---call test02---</span></span>
<span class="line"><span>打桩前: 0</span></span>
<span class="line"><span>打桩后: 100</span></span></code></pre></div><p>test01 先被执行，打桩前调用add(1, 2)的结果是0，打桩后是 100。</p><p>然后 test02 被执行，打桩前调用add(1, 2)的结果是0，而非 100，这证明了我们上面的说法。</p><h3 id="测试-结合powermock支持静态方法" tabindex="-1">测试:结合PowerMock支持静态方法 <a class="header-anchor" href="#测试-结合powermock支持静态方法" aria-label="Permalink to &quot;测试:结合PowerMock支持静态方法&quot;">​</a></h3><blockquote><p>PowerMock 是一个增强库，用来增加 Mockito 、EasyMock 等测试库的功能。</p></blockquote><p>Mockito为什么不能mock静态方法?</p><p>因为Mockito使用继承的方式实现mock的，用CGLIB生成mock对象代替真实的对象进行执行，为了mock实例的方法，你可以在subclass中覆盖它，而static方法是不能被子类覆盖的，所以Mockito不能mock静态方法。</p><p>但PowerMock可以mock静态方法，因为它直接在bytecode上工作。</p><ul><li><strong>Mockito 默认是不支持静态方法</strong></li></ul><p>比如我们在 ExampleService 类中定义静态方法 add：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public class ExampleService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static int add(int a, int b) {</span></span>
<span class="line"><span>        return a+b;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><p>尝试给静态方法打桩，会报错：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span>import org.junit.runner.RunWith;</span></span>
<span class="line"><span>import org.mockito.Mock;</span></span>
<span class="line"><span>import org.mockito.junit.MockitoJUnitRunner;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import static org.mockito.Mockito.*;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@RunWith(MockitoJUnitRunner.class)</span></span>
<span class="line"><span>public class MockitoDemo {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 会报错</span></span>
<span class="line"><span>        when(ExampleService.add(1, 2)).thenReturn(100);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li><strong>可以用 Powermock 弥补 Mockito 缺失的静态方法 mock 功能</strong></li></ul><p>在 pom.xml 中配置以下依赖：(版本的匹配问题可以参考：<a href="https://github.com/powermock/powermock/wiki/Mockito" target="_blank" rel="noreferrer">https://github.com/powermock/powermock/wiki/Mockito</a>)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;properties&gt;</span></span>
<span class="line"><span>    &lt;powermock.version&gt;2.0.2&lt;/powermock.version&gt;</span></span>
<span class="line"><span>&lt;/properties&gt;</span></span>
<span class="line"><span>&lt;dependencies&gt;</span></span>
<span class="line"><span>   &lt;dependency&gt;</span></span>
<span class="line"><span>      &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span></span>
<span class="line"><span>      &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;</span></span>
<span class="line"><span>      &lt;version&gt;\${powermock.version}&lt;/version&gt;</span></span>
<span class="line"><span>      &lt;scope&gt;test&lt;/scope&gt;</span></span>
<span class="line"><span>   &lt;/dependency&gt;</span></span>
<span class="line"><span>   &lt;dependency&gt;</span></span>
<span class="line"><span>      &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span></span>
<span class="line"><span>      &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt;</span></span>
<span class="line"><span>      &lt;version&gt;\${powermock.version}&lt;/version&gt;</span></span>
<span class="line"><span>      &lt;scope&gt;test&lt;/scope&gt;</span></span>
<span class="line"><span>   &lt;/dependency&gt;</span></span>
<span class="line"><span>&lt;/dependencies&gt;</span></span></code></pre></div><p>示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import org.junit.Assert;</span></span>
<span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span>import org.junit.runner.RunWith;</span></span>
<span class="line"><span>import org.powermock.api.mockito.PowerMockito;</span></span>
<span class="line"><span>import org.powermock.core.classloader.annotations.PrepareForTest;</span></span>
<span class="line"><span>import org.powermock.modules.junit4.PowerMockRunner;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import static org.mockito.Mockito.*;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@RunWith(PowerMockRunner.class)     // 这是必须的</span></span>
<span class="line"><span>@PrepareForTest(ExampleService.class)  // 声明要处理 ExampleService</span></span>
<span class="line"><span>public class MockitoDemo {</span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        PowerMockito.mockStatic(ExampleService.class);  // 这也是必须的</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        when(ExampleService.add(1, 2)).thenReturn(100);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Assert.assertEquals(100, ExampleService.add(1, 2));</span></span>
<span class="line"><span>        Assert.assertEquals(0, ExampleService.add(2, 2));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li><strong>PowerMockRunner 支持 Mockito 的 @Mock 等注解</strong></li></ul><p>上面我们用了 PowerMockRunner ，MockitoJUnitRunner 就不能用了。但不要担心， @Mock 等注解还能用。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import org.junit.Assert;</span></span>
<span class="line"><span>import org.junit.Test;</span></span>
<span class="line"><span>import org.junit.runner.RunWith;</span></span>
<span class="line"><span>import org.mockito.Mock;</span></span>
<span class="line"><span>import org.powermock.modules.junit4.PowerMockRunner;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import java.util.Random;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import static org.mockito.Mockito.*;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@RunWith(PowerMockRunner.class)</span></span>
<span class="line"><span>public class MockitoDemo {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Mock</span></span>
<span class="line"><span>    private Random random;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        when(random.nextInt()).thenReturn(1);</span></span>
<span class="line"><span>        Assert.assertEquals(1,  random.nextInt());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><ul><li><a href="https://www.cnblogs.com/oldboyooxx/p/11147474.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/oldboyooxx/p/11147474.html</a></li><li><a href="https://www.cnblogs.com/bodhitree/p/9456515.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/bodhitree/p/9456515.html</a></li></ul><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>`,104)]))}const x=n(r,[["render",d]]);export{b as __pageData,x as default};
