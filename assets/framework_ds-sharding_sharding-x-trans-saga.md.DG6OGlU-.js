import{_ as e,c as r,ai as t,o as s}from"./chunks/framework.BrYByd3F.js";const n="/vitepress-blog-template/images/shardingsphere/sharding-x-trans-saga-2.png",c=JSON.parse('{"title":"ShardingSphere详解 - 事务实现原理之柔性事务SAGA","description":"","frontmatter":{},"headers":[],"relativePath":"framework/ds-sharding/sharding-x-trans-saga.md","filePath":"framework/ds-sharding/sharding-x-trans-saga.md","lastUpdated":1737706346000}'),o={name:"framework/ds-sharding/sharding-x-trans-saga.md"};function i(g,a,h,S,d,p){return s(),r("div",null,a[0]||(a[0]=[t('<h1 id="shardingsphere详解-事务实现原理之柔性事务saga" tabindex="-1">ShardingSphere详解 - 事务实现原理之柔性事务SAGA <a class="header-anchor" href="#shardingsphere详解-事务实现原理之柔性事务saga" aria-label="Permalink to &quot;ShardingSphere详解 - 事务实现原理之柔性事务SAGA&quot;">​</a></h1><blockquote><p>Apache ShardingSphere 在v5.0版本前还支持柔性事务SAGA，目前看5.x+版本中已经移除了向观众章节，本文主要介绍其实现原理; 这篇文章主要转载自<a href="https://shardingsphere.apache.org/document/legacy/4.x/document/cn/features/transaction/concept/base-transaction-saga/" target="_blank" rel="noreferrer">ShardingSphere官方在新窗口打开</a>网站（V4.x版本）。@pdai</p></blockquote><h2 id="saga事务" tabindex="-1">Saga事务 <a class="header-anchor" href="#saga事务" aria-label="Permalink to &quot;Saga事务&quot;">​</a></h2><p>Saga这个概念来源于三十多年前的一篇数据库论文Sagas ，一个Saga事务是一个有多个短时事务组成的长时的事务。 在分布式事务场景下，我们把一个Saga分布式事务看做是一个由多个本地事务组成的事务，每个本地事务都有一个与之对应的补偿事务。在Saga事务的执行过程中，如果某一步执行出现异常，Saga事务会被终止，同时会调用对应的补偿事务完成相关的恢复操作，这样保证Saga相关的本地事务要么都是执行成功，要么通过补偿恢复成为事务执行之前的状态。</p><p><strong>自动反向补偿</strong></p><p>Saga定义了一个事务中的每个子事务都有一个与之对应的反向补偿操作。由Saga事务管理器根据程序执行结果生成一张有向无环图，并在需要执行回滚操作时，根据该图依次按照相反的顺序调用反向补偿操作。Saga事务管理器只用于控制何时重试，何时补偿，并不负责补偿的内容，补偿的具体操作需要由开发者自行提供。</p><p>ShardingSphere采用反向SQL技术，将对数据库进行更新操作的SQL自动生成反向SQL，并交由saga-actuator执行，使用方则无需再关注如何实现补偿方法，将柔性事务管理器的应用范畴成功的定位回了事务的本源——数据库层面。</p><h2 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h2><blockquote><p>Saga柔性事务的实现类为SagaShardingTransactionMananger, ShardingSphere通过Hook的方式拦截逻辑SQL的解析和路由结果，这样，在分片物理SQL执行前，可以生成逆向SQL，在事务提交阶段再把SQL调用链交给Saga引擎处理。</p></blockquote><p><img src="'+n+'" alt="error.图片加载失败"></p><h3 id="init-saga引擎初始化" tabindex="-1">Init（Saga引擎初始化） <a class="header-anchor" href="#init-saga引擎初始化" aria-label="Permalink to &quot;Init（Saga引擎初始化）&quot;">​</a></h3><p>包含Saga柔性事务的应用启动时，saga-actuator引擎会根据saga.properties的配置进行初始化的流程。</p><h3 id="begin-开启saga全局事务" tabindex="-1">Begin（开启Saga全局事务） <a class="header-anchor" href="#begin-开启saga全局事务" aria-label="Permalink to &quot;Begin（开启Saga全局事务）&quot;">​</a></h3><p>每次开启Saga全局事务时，将会生成本次全局事务的上下文（SagaTransactionContext），事务上下文记录了所有子事务的正向SQL和逆向SQL，作为生成事务调用链的元数据使用。</p><h3 id="执行物理sql" tabindex="-1">执行物理SQL <a class="header-anchor" href="#执行物理sql" aria-label="Permalink to &quot;执行物理SQL&quot;">​</a></h3><p>在物理SQL执行前，ShardingSphere根据SQL的类型生成逆向SQL，这里是通过Hook的方式拦截Parser的解析结果进行实现。</p><h3 id="commit-rollback-提交saga事务" tabindex="-1">Commit/rollback（提交Saga事务） <a class="header-anchor" href="#commit-rollback-提交saga事务" aria-label="Permalink to &quot;Commit/rollback（提交Saga事务）&quot;">​</a></h3><p>提交阶段会生成Saga执行引擎所需的调用链路图，commit操作产生ForwardRecovery（正向SQL补偿）任务，rollback操作产生BackwardRecovery任务（逆向SQL补偿）。</p><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',19)]))}const m=e(o,[["render",i]]);export{c as __pageData,m as default};
