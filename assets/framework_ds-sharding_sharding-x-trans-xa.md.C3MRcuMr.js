import{_ as e,c as s,ai as n,o as r}from"./chunks/framework.BrYByd3F.js";const p="/vitepress-blog-template/images/shardingsphere/sharding-x-trans-xa-2.png",t="/vitepress-blog-template/images/shardingsphere/sharding-x-trans-xa-1.png",A=JSON.parse('{"title":"ShardingSphere详解 - 事务实现原理之两阶段事务XA","description":"","frontmatter":{},"headers":[],"relativePath":"framework/ds-sharding/sharding-x-trans-xa.md","filePath":"framework/ds-sharding/sharding-x-trans-xa.md","lastUpdated":1737706346000}'),i={name:"framework/ds-sharding/sharding-x-trans-xa.md"};function o(c,a,l,h,d,u){return r(),s("div",null,a[0]||(a[0]=[n('<h1 id="shardingsphere详解-事务实现原理之两阶段事务xa" tabindex="-1">ShardingSphere详解 - 事务实现原理之两阶段事务XA <a class="header-anchor" href="#shardingsphere详解-事务实现原理之两阶段事务xa" aria-label="Permalink to &quot;ShardingSphere详解 - 事务实现原理之两阶段事务XA&quot;">​</a></h1><blockquote><p>本文主要介绍ShardingSphere分布式事务XA的实现原理; 这篇文章主要转载自<a href="https://shardingsphere.apache.org/document/5.1.0/cn/reference/transaction/base-transaction-seata/" target="_blank" rel="noreferrer">ShardingSphere官方在新窗口打开</a>网站（V5.1.0版本）。@pdai</p></blockquote><h2 id="两阶段事务xa介绍" tabindex="-1">两阶段事务XA介绍 <a class="header-anchor" href="#两阶段事务xa介绍" aria-label="Permalink to &quot;两阶段事务XA介绍&quot;">​</a></h2><p>两阶段事务提交采用的是 X/OPEN 组织所定义的 DTP 模型所抽象的 AP（应用程序）, TM（事务管理器）和 RM（资源管理器） 概念来保证分布式事务的强一致性。 其中 TM 与 RM 间采用 XA 的协议进行双向通信。 与传统的本地事务相比，XA 事务增加了准备阶段，数据库除了被动接受提交指令外，还可以反向通知调用方事务是否可以被提交。 TM 可以收集所有分支事务的准备结果，并于最后进行原子提交，以保证事务的强一致性。</p><p><img src="'+p+'" alt="error.图片加载失败"></p><p>Java 通过定义 JTA 接口实现了 XA 模型，JTA 接口中的 ResourceManager 需要数据库厂商提供 XA 驱动实现， TransactionManager 则需要事务管理器的厂商实现，传统的事务管理器需要同应用服务器绑定，因此使用的成本很高。 而嵌入式的事务管器可以通过 jar 形式提供服务，同 Apache ShardingSphere 集成后，可保证分片后跨库事务强一致性。</p><p>通常，只有使用了事务管理器厂商所提供的 XA 事务连接池，才能支持 XA 的事务。 Apache ShardingSphere 在整合 XA 事务时，采用分离 XA 事务管理和连接池管理的方式，做到对应用程序的零侵入。</p><h2 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h2><blockquote><p>XAShardingSphereTransactionManager 为 Apache ShardingSphere 的分布式事务的 XA 实现类。 它主要负责对多数据源进行管理和适配，并且将相应事务的开启、提交和回滚操作委托给具体的 XA 事务管理器。</p></blockquote><p><img src="'+t+`" alt="error.图片加载失败"></p><h3 id="开启全局事务" tabindex="-1">开启全局事务 <a class="header-anchor" href="#开启全局事务" aria-label="Permalink to &quot;开启全局事务&quot;">​</a></h3><p>收到接入端的 set autoCommit=0 时，XAShardingSphereTransactionManager 将调用具体的 XA 事务管理器开启 XA 全局事务，以 XID 的形式进行标记。</p><h3 id="执行真实分片sql" tabindex="-1">执行真实分片SQL <a class="header-anchor" href="#执行真实分片sql" aria-label="Permalink to &quot;执行真实分片SQL&quot;">​</a></h3><p>XAShardingSphereTransactionManager 将数据库连接所对应的 XAResource 注册到当前 XA 事务中之后，事务管理器会在此阶段发送 XAResource.start 命令至数据库。 数据库在收到 XAResource.end 命令之前的所有 SQL 操作，会被标记为 XA 事务。</p><p>例如:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XAResource1.start             ## Enlist阶段执行</span></span>
<span class="line"><span>statement.execute(&quot;sql1&quot;);    ## 模拟执行一个分片SQL1</span></span>
<span class="line"><span>statement.execute(&quot;sql2&quot;);    ## 模拟执行一个分片SQL2</span></span>
<span class="line"><span>XAResource1.end               ## 提交阶段执行</span></span></code></pre></div><p>示例中的 sql1 和 sql2 将会被标记为 XA 事务。</p><h3 id="提交或回滚事务" tabindex="-1">提交或回滚事务 <a class="header-anchor" href="#提交或回滚事务" aria-label="Permalink to &quot;提交或回滚事务&quot;">​</a></h3><p>XAShardingSphereTransactionManager 在接收到接入端的提交命令后，会委托实际的 XA 事务管理进行提交动作， 事务管理器将收集到的当前线程中所有注册的 XAResource，并发送 XAResource.end 指令，用以标记此 XA 事务边界。 接着会依次发送 prepare 指令，收集所有参与 XAResource 投票。 若所有 XAResource 的反馈结果均为正确，则调用 commit 指令进行最终提交； 若有任意 XAResource 的反馈结果不正确，则调用 rollback 指令进行回滚。 在事务管理器发出提交指令后，任何 XAResource 产生的异常都会通过恢复日志进行重试，以保证提交阶段的操作原子性，和数据强一致性。</p><p>例如:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XAResource1.prepare           ## ack: yes</span></span>
<span class="line"><span>XAResource2.prepare           ## ack: yes</span></span>
<span class="line"><span>XAResource1.commit</span></span>
<span class="line"><span>XAResource2.commit</span></span>
<span class="line"><span></span></span>
<span class="line"><span>XAResource1.prepare           ## ack: yes</span></span>
<span class="line"><span>XAResource2.prepare           ## ack: no</span></span>
<span class="line"><span>XAResource1.rollback</span></span>
<span class="line"><span>XAResource2.rollback</span></span></code></pre></div><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>`,22)]))}const X=e(i,[["render",o]]);export{A as __pageData,X as default};
