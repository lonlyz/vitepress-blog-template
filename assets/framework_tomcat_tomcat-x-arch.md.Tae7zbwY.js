import{_ as e}from"./chunks/tomcat-x-design-2-1.DoncdYAn.js";import{_ as a,c as o,ai as l,o as r}from"./chunks/framework.BrYByd3F.js";const i="/vitepress-blog-template/images/tomcat/tomcat-x-design-2-3.jpg",g=JSON.parse('{"title":"Tomcat - 理解Tomcat架构设计","description":"","frontmatter":{},"headers":[],"relativePath":"framework/tomcat/tomcat-x-arch.md","filePath":"framework/tomcat/tomcat-x-arch.md","lastUpdated":1737706346000}'),n={name:"framework/tomcat/tomcat-x-arch.md"};function s(p,t,c,m,u,h){return r(),o("div",null,t[0]||(t[0]=[l('<h1 id="tomcat-理解tomcat架构设计" tabindex="-1">Tomcat - 理解Tomcat架构设计 <a class="header-anchor" href="#tomcat-理解tomcat架构设计" aria-label="Permalink to &quot;Tomcat - 理解Tomcat架构设计&quot;">​</a></h1><blockquote><p>前文我们已经介绍了一个简单的Servlet容器是如何设计出来，我们就可以开始正式学习Tomcat了，在学习开始，我们有必要站在高点去看看Tomcat的架构设计。@pdai</p></blockquote><h2 id="准备知识" tabindex="-1">准备知识 <a class="header-anchor" href="#准备知识" aria-label="Permalink to &quot;准备知识&quot;">​</a></h2><blockquote><p>一些准备知识点。</p></blockquote><h3 id="tomcat和catalina是什么关系" tabindex="-1">Tomcat和Catalina是什么关系？ <a class="header-anchor" href="#tomcat和catalina是什么关系" aria-label="Permalink to &quot;Tomcat和Catalina是什么关系？&quot;">​</a></h3><blockquote><p>Tomcat的前身为Catalina，Catalina又是一个轻量级的Servlet容器</p></blockquote><p>Tomcat的前身为Catalina，Catalina又是一个轻量级的Servlet容器。在美国，catalina是一个很美的小岛。所以Tomcat作者的寓意可能是想把Tomcat设计成一个优雅美丽且轻量级的web服务器。Tomcat从4.x版本开始除了作为支持Servlet的容器外，额外加入了很多的功能，比如：jsp、el、naming等等，所以说<strong>Tomcat不仅仅是Catalina</strong>。</p><h3 id="什么是servlet" tabindex="-1">什么是Servlet？ <a class="header-anchor" href="#什么是servlet" aria-label="Permalink to &quot;什么是Servlet？&quot;">​</a></h3><blockquote><p>所谓Servlet，其实就是Sun为了让Java能实现动态可交互的网页，从而进入Web编程领域而制定的一套标准！</p></blockquote><p>在互联网兴起之初，当时的Sun公司（后面被Oracle收购）已然看到了这次机遇，于是设计出了Applet来对Web应用的支持。不过事实却并不是预期那么得好，Sun悲催地发现Applet并没有给业界带来多大的影响。经过反思，Sun就想既然机遇出现了，市场前景也非常不错，总不能白白放弃了呀，怎么办呢？于是又投入精力去搞一套规范出来，这时Servlet诞生了！</p><p>一个Servlet主要做下面三件事情：</p><ul><li>创建并填充Request对象，包括：URI、参数、method、请求头信息、请求体信息等</li><li>创建Response对象</li><li>执行业务逻辑，将结果通过Response的输出流输出到客户端</li></ul><p><strong>Servlet没有main方法，所以，如果要执行，则需要在一个容器里面才能执行，这个容器就是为了支持Servlet的功能而存在，Tomcat其实就是一个Servlet容器的实现</strong>。</p><h2 id="tomcat-总结架构" tabindex="-1">Tomcat 总结架构 <a class="header-anchor" href="#tomcat-总结架构" aria-label="Permalink to &quot;Tomcat 总结架构&quot;">​</a></h2><p>下图应该是网上能找的最好的关于Tomcat的架构图了， 我们来看下它的构成：</p><p><img src="'+e+'" alt="error.图片加载失败"></p><h3 id="从组件的角度看" tabindex="-1">从组件的角度看 <a class="header-anchor" href="#从组件的角度看" aria-label="Permalink to &quot;从组件的角度看&quot;">​</a></h3><ul><li><p><strong>Server</strong>: 表示服务器，它提供了一种优雅的方式来启动和停止整个系统，不必单独启停连接器和容器；它是Tomcat构成的顶级构成元素，所有一切均包含在Server中；</p></li><li><p><strong>Service</strong>: 表示服务，Server可以运行多个服务。比如一个Tomcat里面可运行订单服务、支付服务、用户服务等等；Server的实现类StandardServer可以包含一个到多个Services, Service的实现类为StandardService调用了容器(Container)接口，其实是调用了Servlet Engine(引擎)，而且StandardService类中也指明了该Service归属的Server;</p></li><li><p><strong>Container</strong>: 表示容器，可以看做Servlet容器；引擎(Engine)、主机(Host)、上下文(Context)和Wraper均继承自Container接口，所以它们都是容器。</p><ul><li>Engine -- 引擎</li><li>Host -- 主机</li><li>Context -- 上下文</li><li>Wrapper -- 包装器</li></ul></li><li><p><strong>Connector</strong>: 表示连接器, <strong>它将Service和Container连接起来</strong>，首先它需要注册到一个Service，它的作用就是把来自客户端的请求转发到Container(容器)，这就是它为什么称作连接器, 它支持的协议如下：</p><ul><li>支持AJP协议</li><li>支持Http协议</li><li>支持Https协议</li></ul></li><li><p><strong>Service内部</strong>还有各种支撑组件，下面简单罗列一下这些组件</p><ul><li>Manager -- 管理器，用于管理会话Session</li><li>Logger -- 日志器，用于管理日志</li><li>Loader -- 加载器，和类加载有关，只会开放给Context所使用</li><li>Pipeline -- 管道组件，配合Valve实现过滤器功能</li><li>Valve -- 阀门组件，配合Pipeline实现过滤器功能</li><li>Realm -- 认证授权组件</li></ul></li></ul><h3 id="从web-xml配置和模块对应角度" tabindex="-1">从web.xml配置和模块对应角度 <a class="header-anchor" href="#从web-xml配置和模块对应角度" aria-label="Permalink to &quot;从web.xml配置和模块对应角度&quot;">​</a></h3><blockquote><p>上述模块的理解不是孤立的，它直接映射为Tomcat的web.xml配置，让我们联系起来看</p></blockquote><p><img src="'+i+`" alt="error.图片加载失败"></p><h3 id="从一个完整请求的角度来看" tabindex="-1">从一个完整请求的角度来看 <a class="header-anchor" href="#从一个完整请求的角度来看" aria-label="Permalink to &quot;从一个完整请求的角度来看&quot;">​</a></h3><blockquote><p>通过一个完整的HTTP请求，我们还需要把它贯穿起来</p></blockquote><p>假设来自客户的请求为：<a href="http://localhost:8080/test/index.jsp" target="_blank" rel="noreferrer">http://localhost:8080/test/index.jsp</a> 请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector,然后</p><ul><li>Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应</li><li>Engine获得请求localhost:8080/test/index.jsp，匹配它所有虚拟主机Host</li><li>Engine匹配到名为localhost的Host(即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机)</li><li>localhost Host获得请求/test/index.jsp，匹配它所拥有的所有Context</li><li>Host匹配到路径为/test的Context(如果匹配不到就把该请求交给路径名为&quot;&quot;的Context去处理)</li><li>path=&quot;/test&quot;的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet</li><li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类，构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法</li><li>Context把执行完了之后的HttpServletResponse对象返回给Host</li><li>Host把HttpServletResponse对象返回给Engine</li><li>Engine把HttpServletResponse对象返回给Connector</li><li>Connector把HttpServletResponse对象返回给客户browser</li></ul><h3 id="从源码的设计角度看" tabindex="-1">从源码的设计角度看 <a class="header-anchor" href="#从源码的设计角度看" aria-label="Permalink to &quot;从源码的设计角度看&quot;">​</a></h3><blockquote><p>从功能的角度将Tomcat源代码分成5个子模块，分别是:</p></blockquote><ul><li><p><strong>Jsper模</strong>: 这个子模块负责jsp页面的解析、jsp属性的验证，同时也负责将jsp页面动态转换为java代码并编译成class文件。在Tomcat源代码中，凡是属于org.apache.jasper包及其子包中的源代码都属于这个子模块;</p></li><li><p><strong>Servlet和Jsp模块</strong>: 这个子模块的源代码属于javax.servlet包及其子包，如我们非常熟悉的javax.servlet.Servlet接口、javax.servet.http.HttpServlet类及javax.servlet.jsp.HttpJspPage就位于这个子模块中;</p></li><li><p><strong>Catalina模块</strong>: 这个子模块包含了所有以org.apache.catalina开头的java源代码。该子模块的任务是规范了Tomcat的总体架构，定义了Server、Service、Host、Connector、Context、Session及Cluster等关键组件及这些组件的实现，这个子模块大量运用了Composite设计模式。同时也规范了Catalina的启动及停止等事件的执行流程。从代码阅读的角度看，这个子模块应该是我们阅读和学习的重点。</p></li><li><p><strong>Connector模块</strong>: 如果说上面三个子模块实现了Tomcat应用服务器的话，那么这个子模块就是Web服务器的实现。所谓连接器(Connector)就是一个连接客户和应用服务器的桥梁，它接收用户的请求，并把用户请求包装成标准的Http请求(包含协议名称，请求头Head，请求方法是Get还是Post等等)。同时，这个子模块还按照标准的Http协议，负责给客户端发送响应页面，比如在请求页面未发现时，connector就会给客户端浏览器发送标准的Http 404错误响应页面。</p></li><li><p><strong>Resource模块</strong>: 这个子模块包含一些资源文件，如Server.xml及Web.xml配置文件。严格说来，这个子模块不包含java源代码，但是它还是Tomcat编译运行所必需的。</p></li></ul><h3 id="从后续深入理解的角度" tabindex="-1">从后续深入理解的角度 <a class="header-anchor" href="#从后续深入理解的角度" aria-label="Permalink to &quot;从后续深入理解的角度&quot;">​</a></h3><blockquote><p>我们看完上述组件结构后，后续应该重点从哪些角度深入理解Tomcat呢？</p></blockquote><ul><li><strong>基于组件的架构</strong></li></ul><p>我们知道组成Tomcat的是各种各样的组件，每个组件各司其职，组件与组件之间有明确的职责划分，同时组件与组件之间又通过一定的联系相互通信。Tomcat整体就是一个个组件的堆砌！</p><ul><li><strong>基于JMX</strong></li></ul><p>我们在后续阅读Tomcat源码的时候，会发现代码里充斥着大量的类似于下面的代码。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Registry.getRegistry(null, null).invoke(mbeans, &quot;init&quot;, false);</span></span>
<span class="line"><span>Registry.getRegistry(null, null).invoke(mbeans, &quot;start&quot;, false);</span></span></code></pre></div><p>而这实际上就是通过JMX来管理相应对象的代码。这儿我们不会详细讲述什么是JMX，我们只是简单地说明一下JMX的概念，参考JMX百度百科。</p><blockquote><p>JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。</p></blockquote><ul><li><strong>基于生命周期</strong></li></ul><p>如果我们查阅各个组件的源代码，会发现绝大多数组件实现了Lifecycle接口，这也就是我们所说的基于生命周期。生命周期的各个阶段的触发又是基于事件的方式。</p><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>`,40)]))}const b=a(n,[["render",s]]);export{g as __pageData,b as default};
