import{_ as a,c as t,ai as s,o as n}from"./chunks/framework.BrYByd3F.js";const d="/vitepress-blog-template/images/collection/ArrayDeque_base.png",l="/vitepress-blog-template/images/collection/ArrayDeque_addFirst.png",p="/vitepress-blog-template/images/collection/ArrayDeque_doubleCapacity.png",o="/vitepress-blog-template/images/collection/ArrayDeque_addLast.png",g=JSON.parse('{"title":"Collection - Stack & Queue 源码解析","description":"","frontmatter":{},"headers":[],"relativePath":"java/collection/java-collection-Queue&Stack.md","filePath":"java/collection/java-collection-Queue&Stack.md","lastUpdated":1737706346000}'),c={name:"java/collection/java-collection-Queue&Stack.md"};function i(r,e,u,h,m,b){return n(),t("div",null,e[0]||(e[0]=[s('<h1 id="collection-stack-queue-源码解析" tabindex="-1">Collection - Stack &amp; Queue 源码解析 <a class="header-anchor" href="#collection-stack-queue-源码解析" aria-label="Permalink to &quot;Collection - Stack &amp; Queue 源码解析&quot;">​</a></h1><blockquote><p>本文主要对Collection - Stack &amp; Queue进行源码解析。@pdai</p></blockquote><h2 id="stack-queue概述" tabindex="-1">Stack &amp; Queue概述 <a class="header-anchor" href="#stack-queue概述" aria-label="Permalink to &quot;Stack &amp; Queue概述&quot;">​</a></h2><p>Java里有一个叫做_Stack_的类，却没有叫做_Queue_的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用_Stack_，而是推荐使用更高效的_ArrayDeque_；既然_Queue_只是一个接口，当需要使用队列时也就首选_ArrayDeque_了(次选是_LinkedList_)。</p><h2 id="queue" tabindex="-1">Queue <a class="header-anchor" href="#queue" aria-label="Permalink to &quot;Queue&quot;">​</a></h2><p><em>Queue_接口继承自Collection接口，除了最基本的Collection的方法之外，它还支持额外的_insertion</em>, _extraction_和_inspection_操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p><table tabindex="0"><thead><tr><th></th><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td><td>offer(e)</td></tr><tr><td>Remove</td><td>remove()</td><td>poll()</td></tr><tr><td>Examine</td><td>element()</td><td>peek()</td></tr></tbody></table><h2 id="deque" tabindex="-1">Deque <a class="header-anchor" href="#deque" aria-label="Permalink to &quot;Deque&quot;">​</a></h2><p><code>Deque</code>是&quot;double ended queue&quot;, 表示双向的队列，英文读作&quot;deck&quot;. Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下:</p><table tabindex="0"><thead><tr><th></th><th>First Element - Head</th><th></th><th>Last Element - Tail</th><th></th></tr></thead><tbody><tr><td></td><td>Throws exception</td><td>Special value</td><td>Throws exception</td><td>Special value</td></tr><tr><td>Insert</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr><td>Remove</td><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>Examine</td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>当把<code>Deque</code>当做FIFO的<code>queue</code>来使用时，元素是从<code>deque</code>的尾部添加，从头部进行删除的； 所以<code>deque</code>的部分方法是和<code>queue</code>是等同的。具体如下:</p><table tabindex="0"><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td></tr><tr><td>remove()</td><td>removeFirst()</td></tr><tr><td>poll()</td><td>pollFirst()</td></tr><tr><td>element()</td><td>getFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>_Deque_的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了_Deque_与_Queue_相对应的接口:</p><table tabindex="0"><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>add(e)</code></td><td><code>addLast(e)</code></td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td><code>offer(e)</code></td><td><code>offerLast(e)</code></td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td><code>remove()</code></td><td><code>removeFirst()</code></td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td><code>poll()</code></td><td><code>pollFirst()</code></td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td><code>element()</code></td><td><code>getFirst()</code></td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下表列出了_Deque_与_Stack_对应的接口:</p><table tabindex="0"><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>push(e)</code></td><td><code>addFirst(e)</code></td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>offerFirst(e)</code></td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFirst()</code></td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>pollFirst()</code></td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td><code>peek()</code></td><td><code>getFirst()</code></td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><p>上面两个表共定义了_Deque_的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。<strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(<code>false</code>或<code>null</code>)</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。<strong>虽然_Deque_的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p><p><em>ArrayDeque_和_LinkedList_是_Deque_的两个通用实现，由于官方更推荐使用_AarryDeque_用作栈和队列，加之上一篇已经讲解过_LinkedList</em>，本文将着重讲解_ArrayDeque_的具体实现。</p><p>从名字可以看出_ArrayDeque_底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组(circular array)</strong>，也就是说数组的任何一点都可能被看作起点或者终点。_ArrayDeque_是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p><p><img src="'+d+'" alt="ArrayDeque_base.png"></p><p>上图中我们看到，<strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p><h2 id="方法剖析" tabindex="-1">方法剖析 <a class="header-anchor" href="#方法剖析" aria-label="Permalink to &quot;方法剖析&quot;">​</a></h2><h3 id="addfirst" tabindex="-1">addFirst() <a class="header-anchor" href="#addfirst" aria-label="Permalink to &quot;addFirst()&quot;">​</a></h3><p><code>addFirst(E e)</code>的作用是在_Deque_的首端插入元素，也就是在<code>head</code>的前面插入元素，在空间足够且下标没有越界的情况下，只需要将<code>elements[--head] = e</code>即可。</p><p><img src="'+l+`" alt="ArrayDeque_addFirst.png"></p><p>实际需要考虑: 1.空间是否够用，以及2.下标是否越界的问题。上图中，如果<code>head</code>为<code>0</code>之后接着调用<code>addFirst()</code>，虽然空余空间还够用，但<code>head</code>为<code>-1</code>，下标越界了。下列代码很好的解决了这两个问题。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//addFirst(E e)</span></span>
<span class="line"><span>public void addFirst(E e) {</span></span>
<span class="line"><span>    if (e == null)//不允许放入null</span></span>
<span class="line"><span>        throw new NullPointerException();</span></span>
<span class="line"><span>    elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界</span></span>
<span class="line"><span>    if (head == tail)//1.空间是否够用</span></span>
<span class="line"><span>        doubleCapacity();//扩容</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。因为<code>elements.length</code>必需是<code>2</code>的指数倍，<code>elements - 1</code>就是二进制低位全<code>1</code>，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数(其实只可能是-1)，则相当于对其取相对于<code>elements.length</code>的补码。</p><p>下面再说说扩容函数<code>doubleCapacity()</code>，其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:</p><p><img src="`+p+`" alt="ArrayDeque_doubleCapacity.png"></p><p>图中我们看到，复制分两次进行，第一次复制<code>head</code>右边的元素，第二次复制<code>head</code>左边的元素。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//doubleCapacity()</span></span>
<span class="line"><span>private void doubleCapacity() {</span></span>
<span class="line"><span>    assert head == tail;</span></span>
<span class="line"><span>    int p = head;</span></span>
<span class="line"><span>    int n = elements.length;</span></span>
<span class="line"><span>    int r = n - p; // head右边元素的个数</span></span>
<span class="line"><span>    int newCapacity = n &lt;&lt; 1;//原空间的2倍</span></span>
<span class="line"><span>    if (newCapacity &lt; 0)</span></span>
<span class="line"><span>        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span></span>
<span class="line"><span>    Object[] a = new Object[newCapacity];</span></span>
<span class="line"><span>    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分</span></span>
<span class="line"><span>    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分</span></span>
<span class="line"><span>    elements = (E[])a;</span></span>
<span class="line"><span>    head = 0;</span></span>
<span class="line"><span>    tail = n;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="addlast" tabindex="-1">addLast() <a class="header-anchor" href="#addlast" aria-label="Permalink to &quot;addLast()&quot;">​</a></h3><p><code>addLast(E e)</code>的作用是在_Deque_的尾端插入元素，也就是在<code>tail</code>的位置插入元素，由于<code>tail</code>总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用<code>doubleCapacity()</code>进行扩容。</p><p><img src="`+o+`" alt="ArrayDeque_addLast.png"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public void addLast(E e) {</span></span>
<span class="line"><span>    if (e == null)//不允许放入null</span></span>
<span class="line"><span>        throw new NullPointerException();</span></span>
<span class="line"><span>    elements[tail] = e;//赋值</span></span>
<span class="line"><span>    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理</span></span>
<span class="line"><span>        doubleCapacity();//扩容</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>下标越界处理方式<code>addFirt()</code>中已经讲过，不再赘述。</p><h3 id="pollfirst" tabindex="-1">pollFirst() <a class="header-anchor" href="#pollfirst" aria-label="Permalink to &quot;pollFirst()&quot;">​</a></h3><p><code>pollFirst()</code>的作用是删除并返回_Deque_首端元素，也即是<code>head</code>位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于<code>ArrayDeque</code>中不允许放入<code>null</code>，当<code>elements[head] == null</code>时，意味着容器为空。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public E pollFirst() {</span></span>
<span class="line"><span>    int h = head;</span></span>
<span class="line"><span>    E result = elements[head];</span></span>
<span class="line"><span>    if (result == null)//null值意味着deque为空</span></span>
<span class="line"><span>        return null;</span></span>
<span class="line"><span>    elements[h] = null;//let GC work</span></span>
<span class="line"><span>    head = (head + 1) &amp; (elements.length - 1);//下标越界处理</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="polllast" tabindex="-1">pollLast() <a class="header-anchor" href="#polllast" aria-label="Permalink to &quot;pollLast()&quot;">​</a></h3><p><code>pollLast()</code>的作用是删除并返回_Deque_尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public E pollLast() {</span></span>
<span class="line"><span>    int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素</span></span>
<span class="line"><span>    E result = elements[t];</span></span>
<span class="line"><span>    if (result == null)//null值意味着deque为空</span></span>
<span class="line"><span>        return null;</span></span>
<span class="line"><span>    elements[t] = null;//let GC work</span></span>
<span class="line"><span>    tail = t;</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="peekfirst" tabindex="-1">peekFirst() <a class="header-anchor" href="#peekfirst" aria-label="Permalink to &quot;peekFirst()&quot;">​</a></h3><p><code>peekFirst()</code>的作用是返回但不删除_Deque_首端元素，也即是<code>head</code>位置处的元素，直接返回<code>elements[head]</code>即可。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public E peekFirst() {</span></span>
<span class="line"><span>    return elements[head]; // elements[head] is null if deque empty</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="peeklast" tabindex="-1">peekLast() <a class="header-anchor" href="#peeklast" aria-label="Permalink to &quot;peekLast()&quot;">​</a></h3><p><code>peekLast()</code>的作用是返回但不删除_Deque_尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public E peekLast() {</span></span>
<span class="line"><span>    return elements[(tail - 1) &amp; (elements.length - 1)];</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>`,51)]))}const q=a(c,[["render",i]]);export{g as __pageData,q as default};
