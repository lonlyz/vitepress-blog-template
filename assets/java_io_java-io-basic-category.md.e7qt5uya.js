import{_ as e,a as r}from"./chunks/java-io-category-3.wjhSINbJ.js";import{_ as t,c as i,ai as o,o as l}from"./chunks/framework.BrYByd3F.js";const p="/vitepress-blog-template/images/io/java-io-category-1-1.png",d="/vitepress-blog-template/images/io/java-io-category-2-1.png",_=JSON.parse('{"title":"Java IO - 分类(传输，操作)","description":"","frontmatter":{},"headers":[],"relativePath":"java/io/java-io-basic-category.md","filePath":"java/io/java-io-basic-category.md","lastUpdated":1737706346000}'),h={name:"java/io/java-io-basic-category.md"};function n(u,a,c,s,m,b){return l(),i("div",null,a[0]||(a[0]=[o('<h1 id="java-io-分类-传输-操作" tabindex="-1">Java IO - 分类(传输，操作) <a class="header-anchor" href="#java-io-分类-传输-操作" aria-label="Permalink to &quot;Java IO - 分类(传输，操作)&quot;">​</a></h1><blockquote><p>本文主要从<code>传输方式</code>和<code>数据操作</code>两个方面分析Java IO的分类。@pdai</p></blockquote><h2 id="io理解分类-从传输方式上" tabindex="-1">IO理解分类 - 从传输方式上 <a class="header-anchor" href="#io理解分类-从传输方式上" aria-label="Permalink to &quot;IO理解分类 - 从传输方式上&quot;">​</a></h2><p>从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:</p><ul><li>字节流</li><li>字符流</li></ul><p><code>字节</code>是个计算机看的，<code>字符</code>才是给人看的</p><h3 id="字节流" tabindex="-1">字节流 <a class="header-anchor" href="#字节流" aria-label="Permalink to &quot;字节流&quot;">​</a></h3><p>(整体结构如下，部分派生类有缺失)</p><p><img src="'+p+'" alt="error.图片加载失败"></p><h3 id="字符流" tabindex="-1">字符流 <a class="header-anchor" href="#字符流" aria-label="Permalink to &quot;字符流&quot;">​</a></h3><p>(整体结构如下，部分派生类有缺失)</p><p><img src="'+d+'" alt="error.图片加载失败"></p><h3 id="字节流和字符流的区别" tabindex="-1">字节流和字符流的区别 <a class="header-anchor" href="#字节流和字符流的区别" aria-label="Permalink to &quot;字节流和字符流的区别&quot;">​</a></h3><ul><li>字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码中文汉字是 3 个字节，GBK编码中文汉字是 2 个字节。)</li><li>字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</li></ul><blockquote><p>简而言之，字节是给计算机看的，字符才是给人看的。</p></blockquote><h3 id="字节转字符input-outputstreamreader-writer" tabindex="-1">字节转字符Input/OutputStreamReader/Writer <a class="header-anchor" href="#字节转字符input-outputstreamreader-writer" aria-label="Permalink to &quot;字节转字符Input/OutputStreamReader/Writer&quot;">​</a></h3><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p><p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li><li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li></ul><p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p><p>Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p><p><img src="'+e+'" alt="error.图片加载失败"></p><h2 id="io理解分类-从数据操作上" tabindex="-1">IO理解分类 - 从数据操作上 <a class="header-anchor" href="#io理解分类-从数据操作上" aria-label="Permalink to &quot;IO理解分类 - 从数据操作上&quot;">​</a></h2><p>从数据来源或者说是操作对象角度看，IO 类可以分为:</p><p><img src="'+r+'" alt="error.图片加载失败"></p><h3 id="文件-file" tabindex="-1">文件(file) <a class="header-anchor" href="#文件-file" aria-label="Permalink to &quot;文件(file)&quot;">​</a></h3><p>FileInputStream、FileOutputStream、FileReader、FileWriter</p><h3 id="数组" tabindex="-1">数组([]) <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组(\\[\\])&quot;">​</a></h3><ul><li>字节数组(byte[]): ByteArrayInputStream、ByteArrayOutputStream</li><li>字符数组(char[]): CharArrayReader、CharArrayWriter</li></ul><h3 id="管道操作" tabindex="-1">管道操作 <a class="header-anchor" href="#管道操作" aria-label="Permalink to &quot;管道操作&quot;">​</a></h3><p>PipedInputStream、PipedOutputStream、PipedReader、PipedWriter</p><h3 id="基本数据类型" tabindex="-1">基本数据类型 <a class="header-anchor" href="#基本数据类型" aria-label="Permalink to &quot;基本数据类型&quot;">​</a></h3><p>DataInputStream、DataOutputStream</p><h3 id="缓冲操作" tabindex="-1">缓冲操作 <a class="header-anchor" href="#缓冲操作" aria-label="Permalink to &quot;缓冲操作&quot;">​</a></h3><p>BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</p><h3 id="打印" tabindex="-1">打印 <a class="header-anchor" href="#打印" aria-label="Permalink to &quot;打印&quot;">​</a></h3><p>PrintStream、PrintWriter</p><h3 id="对象序列化反序列化" tabindex="-1">对象序列化反序列化 <a class="header-anchor" href="#对象序列化反序列化" aria-label="Permalink to &quot;对象序列化反序列化&quot;">​</a></h3><p>ObjectInputStream、ObjectOutputStream</p><h3 id="转换" tabindex="-1">转换 <a class="header-anchor" href="#转换" aria-label="Permalink to &quot;转换&quot;">​</a></h3><p>InputStreamReader、OutputStreamWriter</p><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',42)]))}const P=t(h,[["render",n]]);export{_ as __pageData,P as default};
