import{_ as e,c as s,ai as n,o as t}from"./chunks/framework.BrYByd3F.js";const u=JSON.parse('{"title":"Java 8 - 类型注解","description":"","frontmatter":{},"headers":[],"relativePath":"java/java8/java8-type-anno.md","filePath":"java/java8/java8-type-anno.md","lastUpdated":1737706346000}'),p={name:"java/java8/java8-type-anno.md"};function l(i,a,o,r,c,d){return t(),s("div",null,a[0]||(a[0]=[n(`<h1 id="java-8-类型注解" tabindex="-1">Java 8 - 类型注解 <a class="header-anchor" href="#java-8-类型注解" aria-label="Permalink to &quot;Java 8 - 类型注解&quot;">​</a></h1><blockquote><p>理解Java 8 类型注解需理解几个问题: @pdai</p></blockquote><ul><li><a href="about:blank#java-8---%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3" target="_blank" rel="noreferrer">Java 8 - 类型注解</a><ul><li><a href="about:blank#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3" target="_blank" rel="noreferrer">什么是类型注解</a></li><li><a href="about:blank#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8" target="_blank" rel="noreferrer">类型注解的作用</a></li><li><a href="about:blank#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E5%90%91%E4%B8%8B%E5%85%BC%E5%AE%B9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" target="_blank" rel="noreferrer">类型注解向下兼容的解决方案</a></li><li><a href="about:blank#%E5%85%B3%E4%BA%8Ejsr-308" target="_blank" rel="noreferrer">关于JSR 308</a></li><li><a href="about:blank#%E6%80%BB%E7%BB%93" target="_blank" rel="noreferrer">总结</a></li></ul></li></ul><h2 id="什么是类型注解" tabindex="-1">什么是类型注解 <a class="header-anchor" href="#什么是类型注解" aria-label="Permalink to &quot;什么是类型注解&quot;">​</a></h2><blockquote><p>注解大家都知道，从java5开始加入这一特性，发展到现在已然是遍地开花，在很多框架中得到了广泛的使用，用来简化程序中的配置。那充满争议的类型注解究竟是什么? 复杂还是便捷?</p></blockquote><ol><li><p>在java 8之前，注解只能是在声明的地方所使用，比如类，方法，属性；</p></li><li><p>java 8里面，注解可以应用在任何地方，比如:</p></li></ol><p>创建类实例</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>new @Interned MyObject();</span></span></code></pre></div><p>类型映射</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>myString = (@NonNull String) str;</span></span></code></pre></div><p>implements 语句中</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>class UnmodifiableList&lt;T&gt; implements @Readonly List&lt;@Readonly T&gt; { … }</span></span></code></pre></div><p>throw exception声明</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>void monitorTemperature() throws @Critical TemperatureException { … }</span></span></code></pre></div><p>需要注意的是，<strong>类型注解只是语法而不是语义，并不会影响java的编译时间，加载时间，以及运行时间，也就是说，编译成class文件的时候并不包含类型注解</strong>。</p><h2 id="类型注解的作用" tabindex="-1">类型注解的作用 <a class="header-anchor" href="#类型注解的作用" aria-label="Permalink to &quot;类型注解的作用&quot;">​</a></h2><p>先看看下面代码</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Collections.emptyList().add(&quot;One&quot;);</span></span>
<span class="line"><span>int i=Integer.parseInt(&quot;hello&quot;);</span></span>
<span class="line"><span>System.console().readLine();</span></span></code></pre></div><p>上面的代码编译是通过的，但运行是会分别报UnsupportedOperationException； NumberFormatException；NullPointerException异常，这些都是runtime error；</p><p>类型注解被用来支持在Java的程序中做强类型检查。配合插件式的check framework，可以在编译的时候检测出runtime error，以提高代码质量。这就是类型注解的作用了。</p><p>check framework是第三方工具，配合Java的类型注解效果就是1+1&gt;2。它可以嵌入到javac编译器里面，可以配合ant和maven使用, 地址是<a href="http://types.cs.washington.edu/checker-framework/%E3%80%82" target="_blank" rel="noreferrer">http://types.cs.washington.edu/checker-framework/。</a> check framework可以找到类型注解出现的地方并检查，举个简单的例子:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import checkers.nullness.quals.*;</span></span>
<span class="line"><span>public class GetStarted {</span></span>
<span class="line"><span>    void sample() {</span></span>
<span class="line"><span>        @NonNull Object ref = new Object();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>使用javac编译上面的类</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>javac -processor checkers.nullness.NullnessChecker GetStarted.java</span></span></code></pre></div><p>编译是通过，但如果修改成</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@NonNull Object ref = null;</span></span></code></pre></div><p>再次编译，则出现</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GetStarted.java:5: incompatible types.</span></span>
<span class="line"><span>found   : @Nullable &lt;nulltype&gt;</span></span>
<span class="line"><span>required: @NonNull Object</span></span>
<span class="line"><span>        @NonNull Object ref = null;</span></span>
<span class="line"><span>                              ^</span></span>
<span class="line"><span>1 error</span></span></code></pre></div><h2 id="类型注解向下兼容的解决方案" tabindex="-1">类型注解向下兼容的解决方案 <a class="header-anchor" href="#类型注解向下兼容的解决方案" aria-label="Permalink to &quot;类型注解向下兼容的解决方案&quot;">​</a></h2><p>如果你不想使用类型注解检测出来错误，则不需要processor，直接javac GetStarted.java是可以编译通过的，这是在java 8 with Type Annotation Support版本里面可以，但java 5,6,7版本都不行，因为javac编译器不知道@NonNull是什么东西，但check framework 有个向下兼容的解决方案，就是将类型注解nonnull用/**/注释起来，比如上面例子修改为</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import checkers.nullness.quals.*;</span></span>
<span class="line"><span>public class GetStarted {</span></span>
<span class="line"><span>    void sample() {</span></span>
<span class="line"><span>        /*@NonNull*/ Object ref = null;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这样javac编译器就会忽略掉注释块，但用check framework里面的javac编译器同样能够检测出nonnull错误。 通过类型注解+check framework我们可以看到，现在runtime error可以在编译时候就能找到。</p><h2 id="关于jsr-308" tabindex="-1">关于JSR 308 <a class="header-anchor" href="#关于jsr-308" aria-label="Permalink to &quot;关于JSR 308&quot;">​</a></h2><p>JSR 308想要解决在Java 1.5注解中出现的两个问题:</p><ul><li>在句法上对注解的限制: 只能把注解写在声明的地方</li><li>类型系统在语义上的限制: 类型系统还做不到预防所有的bug</li></ul><p>JSR 308 通过如下方法解决上述两个问题:</p><ul><li>对Java语言的句法进行扩充，允许注解出现在更多的位置上。包括: 方法接收器(method receivers，译注: 例public int size() @Readonly { … })，泛型参数，数组，类型转换，类型测试，对象创建，类型参数绑定，类继承和throws子句。其实就是类型注解，现在是java 8的一个特性</li><li>通过引入可插拔的类型系统(pluggable type systems)能够创建功能更强大的注解处理器。类型检查器对带有类型限定注解的源码进行分析，一旦发现不匹配等错误之处就会产生警告信息。其实就是check framework</li></ul><p>对JSR308，有人反对，觉得更复杂更静态了，比如</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@NotEmpty List&lt;@NonNull String&gt; strings = new ArrayList&lt;@NonNull String&gt;()&gt;</span></span></code></pre></div><p>换成动态语言为</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var strings = [&quot;one&quot;, &quot;two&quot;];</span></span></code></pre></div><p>有人赞成，说到底，代码才是“最根本”的文档。代码中包含的注解清楚表明了代码编写者的意图。当没有及时更新或者有遗漏的时候，恰恰是注解中包含的意图信息，最容易在其他文档中被丢失。而且将运行时的错误转到编译阶段，不但可以加速开发进程，还可以节省测试时检查bug的时间。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>并不是人人都喜欢这个特性，特别是动态语言比较流行的今天，所幸，java 8并不强求大家使用这个特性，反对的人可以不使用这一特性，而对代码质量有些要求比较高的人或公司可以采用JSR 308，毕竟代码才是“最基本”的文档，这句话我是赞同的。虽然代码会增多，但可以使你的代码更具有表达意义。对这个特性有何看法，大家各抒己见。。。。</p><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>`,45)]))}const b=e(p,[["render",l]]);export{u as __pageData,b as default};
