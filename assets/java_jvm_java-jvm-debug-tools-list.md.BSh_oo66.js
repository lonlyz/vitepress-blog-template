import{_ as s,c as n,ai as e,o as p}from"./chunks/framework.BrYByd3F.js";const u=JSON.parse('{"title":"调试排错 - Java 问题排查之工具单","description":"","frontmatter":{},"headers":[],"relativePath":"java/jvm/java-jvm-debug-tools-list.md","filePath":"java/jvm/java-jvm-debug-tools-list.md","lastUpdated":1737706346000}'),t={name:"java/jvm/java-jvm-debug-tools-list.md"};function l(i,a,o,r,c,d){return p(),n("div",null,a[0]||(a[0]=[e(`<h1 id="调试排错-java-问题排查之工具单" tabindex="-1">调试排错 - Java 问题排查之工具单 <a class="header-anchor" href="#调试排错-java-问题排查之工具单" aria-label="Permalink to &quot;调试排错 - Java 问题排查之工具单&quot;">​</a></h1><blockquote><p>Java 在线问题排查主要分两篇：本文是第二篇，通过java调试/排查工具进行问题定位。@pdai</p></blockquote><h2 id="java-调试入门工具" tabindex="-1">Java 调试入门工具 <a class="header-anchor" href="#java-调试入门工具" aria-label="Permalink to &quot;Java 调试入门工具&quot;">​</a></h2><h3 id="jps" tabindex="-1">jps <a class="header-anchor" href="#jps" aria-label="Permalink to &quot;jps&quot;">​</a></h3><blockquote><p>jps是jdk提供的一个查看当前java进程的小工具， 可以看做是JavaVirtual Machine Process Status Tool的缩写。</p></blockquote><p>jps常用命令</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jps # 显示进程的ID 和 类的名称</span></span>
<span class="line"><span>jps –l # 输出输出完全的包名，应用主类名，jar的完全路径名 </span></span>
<span class="line"><span>jps –v # 输出jvm参数</span></span>
<span class="line"><span>jps –q # 显示java进程号</span></span>
<span class="line"><span>jps -m # main 方法</span></span>
<span class="line"><span>jps -l xxx.xxx.xx.xx # 远程查看</span></span></code></pre></div><p>jps参数</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-q：仅输出VM标识符，不包括classname,jar name,arguments in main method </span></span>
<span class="line"><span>-m：输出main method的参数 </span></span>
<span class="line"><span>-l：输出完全的包名，应用主类名，jar的完全路径名 </span></span>
<span class="line"><span>-v：输出jvm参数 </span></span>
<span class="line"><span>-V：输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件 </span></span>
<span class="line"><span>-Joption：传递参数到vm,例如:-J-Xms512m</span></span></code></pre></div><p>jps原理</p><blockquote><p>java程序在启动以后，会在java.io.tmpdir指定的目录下，就是临时文件夹里，生成一个类似于hsperfdata_User的文件夹，这个文件夹里（在Linux中为/tmp/hsperfdata_{userName}/），有几个文件，名字就是java进程的pid，因此列出当前运行的java进程，只是把这个目录里的文件名列一下而已。 至于系统的参数什么，就可以解析这几个文件获得。</p></blockquote><p>更多请参考 <a href="https://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jps.html" target="_blank" rel="noreferrer">jps - Java Virtual Machine Process Status Tool在新窗口打开</a></p><h3 id="jstack" tabindex="-1">jstack <a class="header-anchor" href="#jstack" aria-label="Permalink to &quot;jstack&quot;">​</a></h3><blockquote><p>jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出 Java 应用程序中线程堆栈信息。</p></blockquote><p>jstack常用命令:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 基本</span></span>
<span class="line"><span>jstack 2815</span></span>
<span class="line"><span></span></span>
<span class="line"><span># java和native c/c++框架的所有栈信息</span></span>
<span class="line"><span>jstack -m 2815</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 额外的锁信息列表，查看是否死锁</span></span>
<span class="line"><span>jstack -l 2815</span></span></code></pre></div><p>jstack参数：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-l 长列表. 打印关于锁的附加信息,例如属于java.util.concurrent 的 ownable synchronizers列表.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-F 当’jstack [-l] pid’没有相应的时候强制打印栈信息</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-m 打印java和native c/c++框架的所有栈信息.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-h | -help 打印帮助信息</span></span></code></pre></div><p>更多请参考: <a href="https://www.jianshu.com/p/025cb069cb69" target="_blank" rel="noreferrer">jvm 性能调优工具之 jstack在新窗口打开</a></p><h3 id="jinfo" tabindex="-1">jinfo <a class="header-anchor" href="#jinfo" aria-label="Permalink to &quot;jinfo&quot;">​</a></h3><blockquote><p>jinfo 是 JDK 自带的命令，可以用来查看正在运行的 java 应用程序的扩展参数，包括Java System属性和JVM命令行参数；也可以动态的修改正在运行的 JVM 一些参数。当系统崩溃时，jinfo可以从core文件里面知道崩溃的Java应用程序的配置信息</p></blockquote><p>jinfo常用命令:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 输出当前 jvm 进程的全部参数和系统属性</span></span>
<span class="line"><span>jinfo 2815</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 输出所有的参数</span></span>
<span class="line"><span>jinfo -flags 2815</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 查看指定的 jvm 参数的值</span></span>
<span class="line"><span>jinfo -flag PrintGC 2815</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 开启/关闭指定的JVM参数</span></span>
<span class="line"><span>jinfo -flag +PrintGC 2815</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 设置flag的参数</span></span>
<span class="line"><span>jinfo -flag name=value 2815</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 输出当前 jvm 进行的全部的系统属性</span></span>
<span class="line"><span>jinfo -sysprops 2815</span></span></code></pre></div><p>jinfo参数：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>no option 输出全部的参数和系统属性</span></span>
<span class="line"><span>-flag name 输出对应名称的参数</span></span>
<span class="line"><span>-flag [+|-]name 开启或者关闭对应名称的参数</span></span>
<span class="line"><span>-flag name=value 设定对应名称的参数</span></span>
<span class="line"><span>-flags 输出全部的参数</span></span>
<span class="line"><span>-sysprops 输出系统属性</span></span></code></pre></div><p>更多请参考：<a href="https://www.jianshu.com/p/8d8aef212b25" target="_blank" rel="noreferrer">jvm 性能调优工具之 jinfo在新窗口打开</a></p><h3 id="jmap" tabindex="-1">jmap <a class="header-anchor" href="#jmap" aria-label="Permalink to &quot;jmap&quot;">​</a></h3><blockquote><p>命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件， 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</p></blockquote><p>两个用途</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 查看堆的情况</span></span>
<span class="line"><span>jmap -heap 2815</span></span>
<span class="line"><span></span></span>
<span class="line"><span># dump</span></span>
<span class="line"><span>jmap -dump:live,format=b,file=/tmp/heap2.bin 2815</span></span>
<span class="line"><span>jmap -dump:format=b,file=/tmp/heap3.bin 2815</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 查看堆的占用</span></span>
<span class="line"><span>jmap -histo 2815 | head -10</span></span></code></pre></div><p>jmap参数</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>no option： 查看进程的内存映像信息,类似 Solaris pmap 命令。</span></span>
<span class="line"><span>heap： 显示Java堆详细信息</span></span>
<span class="line"><span>histo[:live]： 显示堆中对象的统计信息</span></span>
<span class="line"><span>clstats：打印类加载器信息</span></span>
<span class="line"><span>finalizerinfo： 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span></span>
<span class="line"><span>dump:&lt;dump-options&gt;：生成堆转储快照</span></span>
<span class="line"><span>F： 当-dump没有响应时，使用-dump或者-histo参数. 在这个模式下,live子参数无效.</span></span>
<span class="line"><span>help：打印帮助信息</span></span>
<span class="line"><span>J&lt;flag&gt;：指定传递给运行jmap的JVM的参数</span></span></code></pre></div><p>更多请参考：<a href="https://www.jianshu.com/p/a4ad53179df3" target="_blank" rel="noreferrer">jvm 性能调优工具之 jmap在新窗口打开</a> 和 <a href="https://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jmap.html" target="_blank" rel="noreferrer">jmap - Memory Map在新窗口打开</a></p><h3 id="jstat" tabindex="-1">jstat <a class="header-anchor" href="#jstat" aria-label="Permalink to &quot;jstat&quot;">​</a></h3><p>jstat参数众多，但是使用一个就够了</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jstat -gcutil 2815 1000</span></span></code></pre></div><h3 id="jdb" tabindex="-1">jdb <a class="header-anchor" href="#jdb" aria-label="Permalink to &quot;jdb&quot;">​</a></h3><p>jdb可以用来预发debug,假设你预发的java_home是/opt/java/，远程调试端口是8000.那么</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jdb -attach 8000</span></span></code></pre></div><p>出现以上代表jdb启动成功。后续可以进行设置断点进行调试。</p><p>具体参数可见oracle官方说明<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html" target="_blank" rel="noreferrer">jdb - The Java Debugger在新窗口打开</a></p><h3 id="chlsdb" tabindex="-1">CHLSDB <a class="header-anchor" href="#chlsdb" aria-label="Permalink to &quot;CHLSDB&quot;">​</a></h3><p>CHLSDB感觉很多情况下可以看到更好玩的东西，不详细叙述了。 查询资料听说jstack和jmap等工具就是基于它的。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>java -classpath /opt/taobao/java/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB</span></span></code></pre></div><p>更详细的可见R大此贴 <a href="http://rednaxelafx.iteye.com/blog/1847971" target="_blank" rel="noreferrer">http://rednaxelafx.iteye.com/blog/1847971</a></p><h2 id="java-调试进阶工具" tabindex="-1">Java 调试进阶工具 <a class="header-anchor" href="#java-调试进阶工具" aria-label="Permalink to &quot;Java 调试进阶工具&quot;">​</a></h2><h3 id="btrace" tabindex="-1">btrace <a class="header-anchor" href="#btrace" aria-label="Permalink to &quot;btrace&quot;">​</a></h3><p>首当其冲的要说的是btrace。真是生产环境&amp;预发的排查问题大杀器。 简介什么的就不说了。直接上代码干</p><ul><li>查看当前谁调用了ArrayList的add方法，同时只打印当前ArrayList的size大于500的线程调用栈</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@OnMethod(clazz = &quot;java.util.ArrayList&quot;, method=&quot;add&quot;, location = @Location(value = Kind.CALL, clazz = &quot;/./&quot;, method = &quot;/./&quot;))</span></span>
<span class="line"><span>public static void m(@ProbeClassName String probeClass, @ProbeMethodName String probeMethod, @TargetInstance Object instance, @TargetMethodOrField String method) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if(getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance) &gt; 479){</span></span>
<span class="line"><span>        println(&quot;check who ArrayList.add method:&quot; + probeClass + &quot;#&quot; + probeMethod  + &quot;, method:&quot; + method + &quot;, size:&quot; + getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance));</span></span>
<span class="line"><span>        jstack();</span></span>
<span class="line"><span>        println();</span></span>
<span class="line"><span>        println(&quot;===========================&quot;);</span></span>
<span class="line"><span>        println();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li>监控当前服务方法被调用时返回的值以及请求的参数</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@OnMethod(clazz = &quot;com.taobao.sellerhome.transfer.biz.impl.C2CApplyerServiceImpl&quot;, method=&quot;nav&quot;, location = @Location(value = Kind.RETURN))</span></span>
<span class="line"><span>public static void mt(long userId, int current, int relation, String check, String redirectUrl, @Return AnyType result) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    println(&quot;parameter# userId:&quot; + userId + &quot;, current:&quot; + current + &quot;, relation:&quot; + relation + &quot;, check:&quot; + check + &quot;, redirectUrl:&quot; + redirectUrl + &quot;, result:&quot; + result);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>btrace 具体可以参考这里：<a href="https://github.com/btraceio/btrace" target="_blank" rel="noreferrer">https://github.com/btraceio/btrace</a></p><p>注意:</p><ul><li>经过观察，1.3.9的release输出不稳定，要多触发几次才能看到正确的结果</li><li>正则表达式匹配trace类时范围一定要控制，否则极有可能出现跑满CPU导致应用卡死的情况</li><li>由于是字节码注入的原理，想要应用恢复到正常情况，需要重启应用。</li></ul><h3 id="greys" tabindex="-1">Greys <a class="header-anchor" href="#greys" aria-label="Permalink to &quot;Greys&quot;">​</a></h3><p>Greys是@杜琨的大作吧。说几个挺棒的功能(部分功能和btrace重合):</p><ul><li><p><code>sc -df xxx</code>: 输出当前类的详情,包括源码位置和classloader结构</p></li><li><p><code>trace class method</code>: 打印出当前方法调用的耗时情况，细分到每个方法, 对排查方法性能时很有帮助。</p></li></ul><h3 id="arthas" tabindex="-1">Arthas <a class="header-anchor" href="#arthas" aria-label="Permalink to &quot;Arthas&quot;">​</a></h3><blockquote><p>Arthas是基于Greys。</p></blockquote><p>具体请参考：<a href="https://pdai.tech/md/java/jvm/java-jvm-agent-arthas.html" target="_blank" rel="noreferrer">调试排错 - Java应用在线调试Arthas</a></p><h3 id="javosize" tabindex="-1">javOSize <a class="header-anchor" href="#javosize" aria-label="Permalink to &quot;javOSize&quot;">​</a></h3><p>就说一个功能:</p><ul><li><code>classes</code>：通过修改了字节码，改变了类的内容，即时生效。 所以可以做到快速的在某个地方打个日志看看输出，缺点是对代码的侵入性太大。但是如果自己知道自己在干嘛，的确是不错的玩意儿。</li></ul><p>其他功能Greys和btrace都能很轻易做的到，不说了。</p><p>更多请参考：<a href="http://www.javosize.com/" target="_blank" rel="noreferrer">官网在新窗口打开</a></p><h3 id="jprofiler" tabindex="-1">JProfiler <a class="header-anchor" href="#jprofiler" aria-label="Permalink to &quot;JProfiler&quot;">​</a></h3><p>之前判断许多问题要通过JProfiler，但是现在Greys和btrace基本都能搞定了。再加上出问题的基本上都是生产环境(网络隔离)，所以基本不怎么使用了，但是还是要标记一下。</p><p>更多请参考：<a href="https://www.ej-technologies.com/products/jprofiler/overview.html" target="_blank" rel="noreferrer">官网在新窗口打开</a></p><h2 id="其它工具" tabindex="-1">其它工具 <a class="header-anchor" href="#其它工具" aria-label="Permalink to &quot;其它工具&quot;">​</a></h2><h3 id="dmesg" tabindex="-1">dmesg <a class="header-anchor" href="#dmesg" aria-label="Permalink to &quot;dmesg&quot;">​</a></h3><p>如果发现自己的java进程悄无声息的消失了，几乎没有留下任何线索，那么dmesg一发，很有可能有你想要的。</p><p>sudo dmesg|grep -i kill|less 去找关键字oom_killer。找到的结果类似如下:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[6710782.021013] java invoked oom-killer: gfp_mask=0xd0, order=0, oom_adj=0, oom_scoe_adj=0</span></span>
<span class="line"><span>[6710782.070639] [&lt;ffffffff81118898&gt;] ? oom_kill_process+0x68/0x140 </span></span>
<span class="line"><span>[6710782.257588] Task in /LXC011175068174 killed as a result of limit of /LXC011175068174 </span></span>
<span class="line"><span>[6710784.698347] Memory cgroup out of memory: Kill process 215701 (java) score 854 or sacrifice child </span></span>
<span class="line"><span>[6710784.707978] Killed process 215701, UID 679, (java) total-vm:11017300kB, anon-rss:7152432kB, file-rss:1232kB</span></span></code></pre></div><p>以上表明，对应的java进程被系统的OOM Killer给干掉了，得分为854. 解释一下OOM killer（Out-Of-Memory killer），该机制会监控机器的内存资源消耗。当机器内存耗尽前，该机制会扫描所有的进程（按照一定规则计算，内存占用，时间等），挑选出得分最高的进程，然后杀死，从而保护机器。</p><p>dmesg日志时间转换公式: log实际时间=格林威治1970-01-01+(当前时间秒数-系统启动至今的秒数+dmesg打印的log时间)秒数：</p><p>date -d &quot;1970-01-01 UTC <code>echo &quot;$(date +%s)-$(cat /proc/uptime|cut -f 1 -d&#39; &#39;)+12288812.926194&quot;|bc</code> seconds&quot; 剩下的，就是看看为什么内存这么大，触发了OOM-Killer了。</p><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><ul><li>文章主要参考了如下， 在此基础上重新整理，和添加新内容。</li><li>作者：红魔七号</li><li>文章来源：<a href="https://yq.aliyun.com/articles/69520" target="_blank" rel="noreferrer">https://yq.aliyun.com/articles/69520</a></li><li><a href="https://www.cnblogs.com/xuchunlin/p/5671572.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/xuchunlin/p/5671572.html</a></li></ul><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>`,80)]))}const b=s(t,[["render",l]]);export{u as __pageData,b as default};
