import{_ as e,c as s,ai as n,o as t}from"./chunks/framework.BrYByd3F.js";const h=JSON.parse('{"title":"调试排错 - Java 内存分析之堆内存和MetaSpace内存","description":"","frontmatter":{},"headers":[],"relativePath":"java/jvm/java-jvm-oom.md","filePath":"java/jvm/java-jvm-oom.md","lastUpdated":1737706346000}'),p={name:"java/jvm/java-jvm-oom.md"};function r(l,a,o,i,c,d){return t(),s("div",null,a[0]||(a[0]=[n(`<h1 id="调试排错-java-内存分析之堆内存和metaspace内存" tabindex="-1">调试排错 - Java 内存分析之堆内存和MetaSpace内存 <a class="header-anchor" href="#调试排错-java-内存分析之堆内存和metaspace内存" aria-label="Permalink to &quot;调试排错 - Java 内存分析之堆内存和MetaSpace内存&quot;">​</a></h1><blockquote><p>本文以两个简单的例子(<code>堆内存溢出</code>和<code>MetaSpace (元数据) 内存溢出</code>）解释Java 内存溢出的分析过程。@pdai</p></blockquote><h2 id="常见的内存溢出问题-内存和metaspace内存" tabindex="-1">常见的内存溢出问题(内存和MetaSpace内存) <a class="header-anchor" href="#常见的内存溢出问题-内存和metaspace内存" aria-label="Permalink to &quot;常见的内存溢出问题(内存和MetaSpace内存)&quot;">​</a></h2><blockquote><p>常见的内存溢出问题(内存和MetaSpace内存)。</p></blockquote><h3 id="java-堆内存溢出" tabindex="-1">Java 堆内存溢出 <a class="header-anchor" href="#java-堆内存溢出" aria-label="Permalink to &quot;Java 堆内存溢出&quot;">​</a></h3><p>Java 堆内存（Heap Memory)主要有两种形式的错误：</p><ol><li>OutOfMemoryError: Java heap space</li><li>OutOfMemoryError: GC overhead limit exceeded</li></ol><h4 id="outofmemoryerror-java-heap-space" tabindex="-1">OutOfMemoryError: Java heap space <a class="header-anchor" href="#outofmemoryerror-java-heap-space" aria-label="Permalink to &quot;OutOfMemoryError: Java heap space&quot;">​</a></h4><p>在 Java 堆中只要不断的创建对象，并且 <code>GC-Roots</code> 到对象之间存在引用链，这样 <code>JVM</code> 就不会回收对象。</p><p>只要将<code>-Xms(最小堆)</code>,<code>-Xmx(最大堆)</code> 设置为一样禁止自动扩展堆内存。</p><p>当使用一个 <code>while(true)</code> 循环来不断创建对象就会发生 <code>OutOfMemory</code>，还可以使用 <code>-XX:+HeapDumpOutofMemoryErorr</code> 当发生 OOM 时会自动 dump 堆栈到文件中。</p><p>伪代码:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public static void main(String[] args) {</span></span>
<span class="line"><span>	List&lt;String&gt; list = new ArrayList&lt;&gt;(10) ;</span></span>
<span class="line"><span>	while (true){</span></span>
<span class="line"><span>		list.add(&quot;1&quot;) ;</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>当出现 OOM 时可以通过工具来分析 <code>GC-Roots</code> <a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/GarbageCollection.md#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95" target="_blank" rel="noreferrer">引用链在新窗口打开</a> ，查看对象和 <code>GC-Roots</code> 是如何进行关联的，是否存在对象的生命周期过长，或者是这些对象确实改存在的，那就要考虑将堆内存调大了。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span>
<span class="line"><span>	at java.util.Arrays.copyOf(Arrays.java:3210)</span></span>
<span class="line"><span>	at java.util.Arrays.copyOf(Arrays.java:3181)</span></span>
<span class="line"><span>	at java.util.ArrayList.grow(ArrayList.java:261)</span></span>
<span class="line"><span>	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)</span></span>
<span class="line"><span>	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)</span></span>
<span class="line"><span>	at java.util.ArrayList.add(ArrayList.java:458)</span></span>
<span class="line"><span>	at com.crossoverjie.oom.HeapOOM.main(HeapOOM.java:18)</span></span>
<span class="line"><span>	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></span>
<span class="line"><span>	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span></span>
<span class="line"><span>	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span></span>
<span class="line"><span>	at java.lang.reflect.Method.invoke(Method.java:498)</span></span>
<span class="line"><span>	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Process finished with exit code 1</span></span></code></pre></div><p><code>java.lang.OutOfMemoryError: Java heap space</code>表示堆内存溢出。</p><h4 id="outofmemoryerror-gc-overhead-limit-exceeded" tabindex="-1">OutOfMemoryError: GC overhead limit exceeded <a class="header-anchor" href="#outofmemoryerror-gc-overhead-limit-exceeded" aria-label="Permalink to &quot;OutOfMemoryError: GC overhead limit exceeded&quot;">​</a></h4><p>GC overhead limt exceed检查是Hotspot VM 1.6定义的一个策略，通过统计GC时间来预测是否要OOM了，提前抛出异常，防止OOM发生。Sun 官方对此的定义是：“并行/并发回收器在GC回收时间过长时会抛出OutOfMemroyError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存。用来避免内存过小造成应用不能正常工作。“</p><p>PS：-Xmx最大内存配置2GB</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public void testOom1() {</span></span>
<span class="line"><span>	List&lt;Map&lt;String, Object&gt;&gt; mapList = new ArrayList&lt;&gt;();</span></span>
<span class="line"><span>	for (int i = 0; i &lt; 1000000; i++) {</span></span>
<span class="line"><span>		Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span></span>
<span class="line"><span>		for (int j = 0; j &lt; i; j++) {</span></span>
<span class="line"><span>				map.put(String.valueOf(j), j);</span></span>
<span class="line"><span>		}</span></span>
<span class="line"><span>		mapList.add(map);</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>上述的代码执行会：old区占用过多导致频繁Full GC，最终导致GC overhead limit exceed。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>java.lang.OutOfMemoryError: GC overhead limit exceeded</span></span>
<span class="line"><span>	at java.util.HashMap.newNode(HashMap.java:1747) ~[na:1.8.0_181]</span></span>
<span class="line"><span>	at java.util.HashMap.putVal(HashMap.java:642) ~[na:1.8.0_181]</span></span>
<span class="line"><span>	at java.util.HashMap.put(HashMap.java:612) ~[na:1.8.0_181]</span></span>
<span class="line"><span>	at tech.pdai.test.oom.controller.TestOomController.testOom1(TestOomController.java:33) ~[classes/:na]</span></span>
<span class="line"><span>	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_181]</span></span>
<span class="line"><span>	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_181]</span></span>
<span class="line"><span>	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_181]</span></span>
<span class="line"><span>	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_181]</span></span>
<span class="line"><span>	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:197) ~[spring-web-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:141) ~[spring-web-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) ~[spring-webmvc-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808) ~[spring-webmvc-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1064) ~[spring-webmvc-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) ~[spring-webmvc-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at javax.servlet.http.HttpServlet.service(HttpServlet.java:655) ~[tomcat-embed-core-9.0.50.jar:4.0.FR]</span></span>
<span class="line"><span>	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) ~[tomcat-embed-core-9.0.50.jar:4.0.FR]</span></span>
<span class="line"><span>	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:228) ~[tomcat-embed-core-9.0.50.jar:9.0.50]</span></span>
<span class="line"><span>	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:163) ~[tomcat-embed-core-9.0.50.jar:9.0.50]</span></span>
<span class="line"><span>	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.50.jar:9.0.50]</span></span>
<span class="line"><span>	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:190) ~[tomcat-embed-core-9.0.50.jar:9.0.50]</span></span>
<span class="line"><span>	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:163) ~[tomcat-embed-core-9.0.50.jar:9.0.50]</span></span>
<span class="line"><span>	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:190) ~[tomcat-embed-core-9.0.50.jar:9.0.50]</span></span>
<span class="line"><span>	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:163) ~[tomcat-embed-core-9.0.50.jar:9.0.50]</span></span>
<span class="line"><span>	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.9.jar:5.3.9]</span></span>
<span class="line"><span>	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.9.jar:5.3.9]</span></span></code></pre></div><p>还可以使用 <code>-XX:+HeapDumpOutofMemoryErorr</code> 当发生 OOM 时会自动 dump 堆栈到文件中。</p><p>JVM还有这样一个参数：<code>-XX:-UseGCOverheadLimit</code> 设置为false可以禁用这个检查。其实这个参数解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space。</p><h3 id="metaspace-元数据-内存溢出" tabindex="-1">MetaSpace (元数据) 内存溢出 <a class="header-anchor" href="#metaspace-元数据-内存溢出" aria-label="Permalink to &quot;MetaSpace (元数据) 内存溢出&quot;">​</a></h3><blockquote><p><code>JDK8</code> 中将永久代移除，使用 <code>MetaSpace</code> 来保存类加载之后的类信息，字符串常量池也被移动到 Java 堆。</p></blockquote><p><code>PermSize</code> 和 <code>MaxPermSize</code> 已经不能使用了，在 JDK8 中配置这两个参数将会发出警告。</p><p>JDK 8 中将类信息移到到了本地堆内存(Native Heap)中，将原有的永久代移动到了本地堆中成为 <code>MetaSpace</code> ,如果不指定该区域的大小，JVM 将会动态的调整。</p><p>可以使用 <code>-XX:MaxMetaspaceSize=10M</code> 来限制最大元数据。这样当不停的创建类时将会占满该区域并出现 <code>OOM</code>。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public static void main(String[] args) {</span></span>
<span class="line"><span>	while (true){</span></span>
<span class="line"><span>		Enhancer  enhancer = new Enhancer() ;</span></span>
<span class="line"><span>		enhancer.setSuperclass(HeapOOM.class);</span></span>
<span class="line"><span>		enhancer.setUseCache(false) ;</span></span>
<span class="line"><span>		enhancer.setCallback(new MethodInterceptor() {</span></span>
<span class="line"><span>			@Override</span></span>
<span class="line"><span>			public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {</span></span>
<span class="line"><span>				return methodProxy.invoke(o,objects) ;</span></span>
<span class="line"><span>			}</span></span>
<span class="line"><span>		});</span></span>
<span class="line"><span>		enhancer.create() ;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>使用 <code>cglib</code> 不停的创建新类，最终会抛出:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Caused by: java.lang.reflect.InvocationTargetException</span></span>
<span class="line"><span>	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)</span></span>
<span class="line"><span>	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span></span>
<span class="line"><span>	at java.lang.reflect.Method.invoke(Method.java:498)</span></span>
<span class="line"><span>	at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:459)</span></span>
<span class="line"><span>	at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:336)</span></span>
<span class="line"><span>	... 11 more</span></span>
<span class="line"><span>Caused by: java.lang.OutOfMemoryError: Metaspace</span></span>
<span class="line"><span>	at java.lang.ClassLoader.defineClass1(Native Method)</span></span>
<span class="line"><span>	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span></span>
<span class="line"><span>	... 16 more</span></span></code></pre></div><p>注意: 这里的 OOM 伴随的是 <code>java.lang.OutOfMemoryError: Metaspace</code> 也就是元数据溢出。</p><h2 id="分析案例" tabindex="-1">分析案例 <a class="header-anchor" href="#分析案例" aria-label="Permalink to &quot;分析案例&quot;">​</a></h2><blockquote><p>在实际工作中，如何去定位内存泄漏问题呢？</p></blockquote><h3 id="堆内存dump" tabindex="-1">堆内存dump <a class="header-anchor" href="#堆内存dump" aria-label="Permalink to &quot;堆内存dump&quot;">​</a></h3><ul><li><strong>通过OOM获取</strong></li></ul><p>即在OutOfMemoryError后获取一份HPROF二进制Heap Dump文件，在jvm中添加参数：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-XX:+HeapDumpOnOutOfMemoryError</span></span></code></pre></div><ul><li><strong>主动获取</strong></li></ul><p>在虚拟机添加参数如下，然后在Ctrl+Break组合键即可获取一份Heap Dump</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-XX:+HeapDumpOnCtrlBreak</span></span></code></pre></div><ul><li><strong>使用HPROF agent</strong></li></ul><p>使用Agent可以在程序执行结束时或受到SIGOUT信号时生成Dump文件</p><p>配置在虚拟机的参数如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-agentlib:hprof=heap=dump,format=b</span></span></code></pre></div><ul><li><strong>jmap获取</strong> (常用)</li></ul><p>jmap可以在cmd里执行，命令如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jmap -dump:format=b file=&lt;文件名XX.hprof&gt; &lt;pid&gt;</span></span></code></pre></div><ul><li><strong>使用JConsole</strong></li></ul><p>Acquire Heap Dump</p><ul><li><strong>使用JProfile</strong></li></ul><p>Acquire Heap Dump</p><h3 id="使用mat分析内存" tabindex="-1">使用MAT分析内存 <a class="header-anchor" href="#使用mat分析内存" aria-label="Permalink to &quot;使用MAT分析内存&quot;">​</a></h3><p>MAT 等工具可以看：<a href="https://pdai.tech/md/java/jvm/java-jvm-oom-tool.html#eclipse-memory-analyzer-mat" target="_blank" rel="noreferrer">Java 问题排查之JVM可视化工具 - MAT</a></p><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>`,56)]))}const m=e(p,[["render",r]]);export{h as __pageData,m as default};
