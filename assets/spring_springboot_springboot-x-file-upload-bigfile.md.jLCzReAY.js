import{_ as s,c as n,ai as e,o as p}from"./chunks/framework.BrYByd3F.js";const g=JSON.parse('{"title":"SpringBoot集成文件 - 大文件的上传(异步，分片，断点续传和秒传)","description":"","frontmatter":{},"headers":[],"relativePath":"spring/springboot/springboot-x-file-upload-bigfile.md","filePath":"spring/springboot/springboot-x-file-upload-bigfile.md","lastUpdated":1737706346000}'),t={name:"spring/springboot/springboot-x-file-upload-bigfile.md"};function o(i,a,l,r,c,d){return p(),n("div",null,a[0]||(a[0]=[e(`<h1 id="springboot集成文件-大文件的上传-异步-分片-断点续传和秒传" tabindex="-1">SpringBoot集成文件 - 大文件的上传(异步，分片，断点续传和秒传) <a class="header-anchor" href="#springboot集成文件-大文件的上传-异步-分片-断点续传和秒传" aria-label="Permalink to &quot;SpringBoot集成文件 - 大文件的上传(异步，分片，断点续传和秒传)&quot;">​</a></h1><blockquote><p>上文中介绍的是常规文件的上传和下载，而超大文件的上传技术手段和普通文件上传是有差异的，主要通过基于分片的断点续传和秒传和异步上传等技术手段解决。本文主要介绍SpringBoot集成大文件上传的案例。@pdai</p></blockquote><h2 id="知识准备" tabindex="-1">知识准备 <a class="header-anchor" href="#知识准备" aria-label="Permalink to &quot;知识准备&quot;">​</a></h2><blockquote><p>大文件的上传技术手段和普通文件上传是有差异的，主要通过基于分片的断点续传和秒传和异步上传解决。@pdai</p></blockquote><h3 id="基于分片的断点续传和秒传" tabindex="-1">基于分片的断点续传和秒传 <a class="header-anchor" href="#基于分片的断点续传和秒传" aria-label="Permalink to &quot;基于分片的断点续传和秒传&quot;">​</a></h3><blockquote><p>当我们上传的文件很大时，对大文件的处理通常通过<strong>分片上传</strong>、<strong>断点续传</strong>和<strong>秒传</strong>技术手段实现。</p></blockquote><ul><li><strong>分片上传</strong></li></ul><p>分片上传就是将一个大文件分成若干份大小相等的小块文件，等所有小块文件上传成功后，再将文件进行合并成完整的原始文件。</p><ul><li><strong>断点续传</strong></li></ul><p>断点续传就是重新上传文件时先判断哪些文件块已经上传过了（比如将分片的chuck md5等信息保存在DB中)，如果上传过了则跳过这些块，否则上传没有上传的块。</p><ul><li><strong>秒传</strong></li></ul><p>当用户选择上传一个文件时，服务端检测该文件之前是否已经被上传过，如果服务器已经存有该文件（完全一样），就立马返回前端 “文件已上传成功”。前端随即将进度条更新至100%。 这样给用户的感觉就是 “秒传” 的感觉。</p><p>对于分片上传，<strong>前后端分别需要怎么做呢</strong>？</p><ol><li><strong>前端</strong>：需要将文件file.slice()成多个文件块，并计算每一块的md5值，每次请求上传都是传一个小文件块。</li><li><strong>后端</strong>：需要接收每次上传的文件块并保存文件块的信息（比如md5), 如果已经上传则跳过；最后等所有文件上传完成之后，将所有的文件块合并成一个大文件。</li></ol><h3 id="异步上传" tabindex="-1">异步上传 <a class="header-anchor" href="#异步上传" aria-label="Permalink to &quot;异步上传&quot;">​</a></h3><blockquote><p>当我们上传的文件很大，后台需要处理的时间很长，用户期望切换到其它页面继续工作，而不需要等待完成。这时候我们可以采用异步上传的方式。</p></blockquote><p>在SpringBoot中将一个方法声明为异步方法非常简单，只需两个注解即可<code>@EnableAsync</code>和<code>@Async</code>。</p><ol><li><code>@EnableAsync</code>用于开启SpringBoot支持异步的功能，用在SpringBoot的启动类上。</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@SpringBootApplication</span></span>
<span class="line"><span>@EnableAsync // 这里</span></span>
<span class="line"><span>public class App {</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        SpringApplication.run(App.class, args);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><ol start="2"><li><code>@Async</code>用于方法上，标记该方法为异步处理方法。</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@Service</span></span>
<span class="line"><span>public class UserServiceImpl {</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>    @Async // 这里带@Async的方法，会被当成一个子线程</span></span>
<span class="line"><span>    public void processFile(InputStream inputStream) {</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="实现案例" tabindex="-1">实现案例 <a class="header-anchor" href="#实现案例" aria-label="Permalink to &quot;实现案例&quot;">​</a></h2><blockquote><p>TBD</p></blockquote><h2 id="示例源码" tabindex="-1">示例源码 <a class="header-anchor" href="#示例源码" aria-label="Permalink to &quot;示例源码&quot;">​</a></h2><p><a href="https://github.com/realpdai/tech-pdai-spring-demos" target="_blank" rel="noreferrer">https://github.com/realpdai/tech-pdai-spring-demos</a></p><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><p><a href="https://www.jb51.net/article/212399.htm" target="_blank" rel="noreferrer">https://www.jb51.net/article/212399.htm</a></p><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>`,28)]))}const b=s(t,[["render",o]]);export{g as __pageData,b as default};
