import{_ as e,c as n,ai as s,o as r}from"./chunks/framework.BrYByd3F.js";const i="/vitepress-blog-template/images/spring/springboot/springboot-hikari-1.png",a="/vitepress-blog-template/images/spring/springboot/springboot-hikari-2.png",o="/vitepress-blog-template/images/spring/springboot/springboot-hikari-3.png",b=JSON.parse('{"title":"▶SpringBoot集成连接池 - 数据库连接池和默认连接池HikariCP","description":"","frontmatter":{},"headers":[],"relativePath":"spring/springboot/springboot-x-mysql-HikariCP.md","filePath":"spring/springboot/springboot-x-mysql-HikariCP.md","lastUpdated":1737706346000}'),l={name:"spring/springboot/springboot-x-mysql-HikariCP.md"};function d(p,t,c,u,h,m){return r(),n("div",null,t[0]||(t[0]=[s(`<h1 id="▶springboot集成连接池-数据库连接池和默认连接池hikaricp" tabindex="-1">▶SpringBoot集成连接池 - 数据库连接池和默认连接池HikariCP <a class="header-anchor" href="#▶springboot集成连接池-数据库连接池和默认连接池hikaricp" aria-label="Permalink to &quot;▶SpringBoot集成连接池 - 数据库连接池和默认连接池HikariCP&quot;">​</a></h1><blockquote><p>本文主要介绍数据库连接池，以及SpringBoot集成默认的HikariCP的实践。@pdai</p></blockquote><h2 id="知识准备" tabindex="-1">知识准备 <a class="header-anchor" href="#知识准备" aria-label="Permalink to &quot;知识准备&quot;">​</a></h2><blockquote><p>需要理解数据库连接池的基本原理，Java DataSource规范，常见的连接池等。部分内容整理自<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/1518538?fr=aladdin" target="_blank" rel="noreferrer">百度百科在新窗口打开</a></p></blockquote><h3 id="什么是数据库连接池" tabindex="-1">什么是数据库连接池？ <a class="header-anchor" href="#什么是数据库连接池" aria-label="Permalink to &quot;什么是数据库连接池？&quot;">​</a></h3><blockquote><p>什么是连接池，它要解决什么样的问题呢？</p></blockquote><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p><h3 id="数据库连接池基本原理" tabindex="-1">数据库连接池基本原理？ <a class="header-anchor" href="#数据库连接池基本原理" aria-label="Permalink to &quot;数据库连接池基本原理？&quot;">​</a></h3><p>连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。</p><p>数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素：</p><ul><li>最小连接数</li></ul><p>是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费。</p><ul><li>最大连接数</li></ul><p>是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。</p><ul><li>最小连接数与最大连接数差距</li></ul><p>最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。</p><h3 id="有哪些常见的数据库连接池" tabindex="-1">有哪些常见的数据库连接池？ <a class="header-anchor" href="#有哪些常见的数据库连接池" aria-label="Permalink to &quot;有哪些常见的数据库连接池？&quot;">​</a></h3><blockquote><p>开源的数据库连接池众多，这里我们需要了解曾经常用的开源数据库连接池及其被淘汰原因，并了解目前最常用的数据库连接池。</p></blockquote><ul><li><strong>C3P0(被淘汰：历史悠久，过于复杂，性能差)</strong></li></ul><p>是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布，包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。由于一度是Hibernate内置的数据库连接池而被开发者熟知，但是由于性能和复杂度，官方已经放弃维护。</p><ul><li><strong>DBCP（被淘汰：依赖Commons-Pool，性能差）</strong> DBCP（DataBase Connection Pool）属于Apache顶级项目Commons中的核心子项目。但DBCP并不是独立实现连接池功能的，它内部依赖于Commons-Pool项目，连接池最核心的“池”，就是由Commons-Pool组件提供的，因此，DBCP的性能实际上就是Pool的性能。</li></ul><p>终于在tomcat 7.0版本中，tomcat重新设计开发出了一套连接池（<strong>Tomcat JDBC Pool</strong>）并且于13年9月发布了Commons-Pool 2.0。命脉已经更新的DBCP终于在14年2月份发布了DBCP2.0。但是，毕竟由于长时间没有更新突破的DBCP，已经被人放弃了。</p><ul><li><strong>BoneCP（被淘汰：为解决C3P0/DBCP性能而生，后续出现了更高性能的hikariCP，BoneCP也不再更新）</strong></li></ul><p>是一个快速、开源的数据库连接池。帮用户管理数据连接，让应用程序能更快速地访问数据库。</p><p>BoneCP的出现主要是为了解决C3P0/DBCP连接池性能问题，有一些测试表明其性能提升了25倍。</p><p>后来出现了更高性能的hikariCP，BoneCP也不再更新，所以BoneCP目前也很少被使用。</p><ul><li><strong>Druid</strong></li></ul><p>Druid功能最为全面，sql拦截等功能，统计数据较为全面，具有良好的扩展性</p><h2 id="简单示例" tabindex="-1">简单示例 <a class="header-anchor" href="#简单示例" aria-label="Permalink to &quot;简单示例&quot;">​</a></h2><blockquote><p>主要展示HikariCP的使用配置等。</p></blockquote><p>如下是常用的HikariCP的使用配置</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  datasource:</span></span>
<span class="line"><span>    url: jdbc:mysql://localhost:3306/test_db?useSSL=false&amp;autoReconnect=true&amp;characterEncoding=utf8</span></span>
<span class="line"><span>    driver-class-name: com.mysql.cj.jdbc.Driver</span></span>
<span class="line"><span>    username: root</span></span>
<span class="line"><span>    password: bfXa4Pt2lUUScy8jakXf</span></span>
<span class="line"><span>    # 指定为HikariDataSource</span></span>
<span class="line"><span>    type: com.zaxxer.hikari.HikariDataSource</span></span>
<span class="line"><span>    # hikari连接池配置</span></span>
<span class="line"><span>    hikari:</span></span>
<span class="line"><span>      #连接池名</span></span>
<span class="line"><span>      pool-name: HikariCP</span></span>
<span class="line"><span>      #最小空闲连接数</span></span>
<span class="line"><span>      minimum-idle: 5</span></span>
<span class="line"><span>      # 空闲连接存活最大时间，默认10分钟</span></span>
<span class="line"><span>      idle-timeout: 600000</span></span>
<span class="line"><span>      # 连接池最大连接数，默认是10</span></span>
<span class="line"><span>      maximum-pool-size: 10</span></span>
<span class="line"><span>      # 此属性控制从池返回的连接的默认自动提交行为,默认值：true</span></span>
<span class="line"><span>      auto-commit: true</span></span>
<span class="line"><span>      # 此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认30分钟</span></span>
<span class="line"><span>      max-lifetime: 1800000</span></span>
<span class="line"><span>      # 数据库连接超时时间,默认30秒</span></span>
<span class="line"><span>      connection-timeout: 30000</span></span>
<span class="line"><span>      # 连接测试query</span></span>
<span class="line"><span>      connection-test-query: SELECT 1</span></span></code></pre></div><h2 id="进一步理解" tabindex="-1">进一步理解 <a class="header-anchor" href="#进一步理解" aria-label="Permalink to &quot;进一步理解&quot;">​</a></h2><blockquote><p>通过如下几个问题，进一步理解HikariCP。</p></blockquote><h3 id="springboot2默认连接池hikaricp是如何起作用的" tabindex="-1">SpringBoot2默认连接池HikariCP是如何起作用的？ <a class="header-anchor" href="#springboot2默认连接池hikaricp是如何起作用的" aria-label="Permalink to &quot;SpringBoot2默认连接池HikariCP是如何起作用的？&quot;">​</a></h3><blockquote><p>从SpringBoot自动初始化配置 和 默认的数据源 两个角度理解。</p></blockquote><ul><li><strong>SpringBoot自动初始化配置</strong></li></ul><p>关键代码如下</p><p><img src="`+i+'" alt="error.图片加载失败"></p><p>然后可以找到HikariCP数据源的配置</p><p><img src="'+a+'" alt="error.图片加载失败"></p><p>你可以发现，为了支持动态更新配置（基于MXBean)，这里还设计了一层HikariConfigMXBean接口</p><ul><li><strong>为什么说是默认的数据源呢</strong>？</li></ul><p>首先，springboot-starter-jdbc中默认加载了Hikari</p><p><img src="'+o+`" alt="error.图片加载失败"></p><p>其次，在配置初始化或者加载时都是第一个被加载的</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>private static &lt;T extends DataSource&gt; MappedDataSourceProperties&lt;T&gt; lookupPooled(ClassLoader classLoader,</span></span>
<span class="line"><span>    Class&lt;T&gt; type) {</span></span>
<span class="line"><span>  MappedDataSourceProperties&lt;T&gt; result = null;</span></span>
<span class="line"><span>  result = lookup(classLoader, type, result, &quot;com.zaxxer.hikari.HikariDataSource&quot;,</span></span>
<span class="line"><span>      HikariDataSourceProperties::new);</span></span>
<span class="line"><span>  result = lookup(classLoader, type, result, &quot;org.apache.tomcat.jdbc.pool.DataSource&quot;,</span></span>
<span class="line"><span>      TomcatPoolDataSourceProperties::new);</span></span>
<span class="line"><span>  result = lookup(classLoader, type, result, &quot;org.apache.commons.dbcp2.BasicDataSource&quot;,</span></span>
<span class="line"><span>      MappedDbcp2DataSource::new);</span></span>
<span class="line"><span>  result = lookup(classLoader, type, result, &quot;oracle.ucp.jdbc.PoolDataSourceImpl&quot;,</span></span>
<span class="line"><span>      OraclePoolDataSourceProperties::new, &quot;oracle.jdbc.OracleConnection&quot;);</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="更多hikaricp配置参数" tabindex="-1">更多HikariCP配置参数？ <a class="header-anchor" href="#更多hikaricp配置参数" aria-label="Permalink to &quot;更多HikariCP配置参数？&quot;">​</a></h3><p>从代码的角度，你已经可以看到，可以配置如下：</p><p><img src="`+a+'" alt="error.图片加载失败"></p><p>更具体的可以看<a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noreferrer">官方配置在新窗口打开</a>或者如下<a href="http://www.lanxinbase.com/?p=2482" target="_blank" rel="noreferrer">深蓝Blog总结翻译的配置在新窗口打开</a></p><table tabindex="0"><thead><tr><th>属性</th><th>描述</th><th>构造器默认值</th><th>默认配置validate之后的值</th><th>validate重置</th></tr></thead><tbody><tr><td>autoCommit</td><td>自动提交从池中返回的连接</td><td>TRUE</td><td>TRUE</td><td>–</td></tr><tr><td>connectionTimeout</td><td>等待来自池的连接的最大毫秒数</td><td>SECONDS.toMillis(30) = 30000</td><td>30000</td><td>如果小于250毫秒，则被重置回30秒</td></tr><tr><td>idleTimeout</td><td>连接允许在池中闲置的最长时间 MINUTES.toMillis(10) = 600000</td><td>600000</td><td>如果idleTimeout+1秒&gt;maxLifetime 且 maxLifetime&gt;0，则会被重置为0（代表永远不会退出）；如果idleTimeout!=0且小于10秒，则会被重置为10秒</td><td></td></tr><tr><td>maxLifetime</td><td>池中连接最长生命周期</td><td>MINUTES.toMillis(30) = 1800000</td><td>1800000</td><td>如果不等于0且小于30秒则会被重置回30分钟</td></tr><tr><td>connectionTestQuery</td><td>如果您的驱动程序支持JDBC4，我们强烈建议您不要设置此属性</td><td>null</td><td>null</td><td>–</td></tr><tr><td>minimumIdle</td><td>池中维护的最小空闲连接数</td><td>-1</td><td>10</td><td>minIdle&lt;0或者minIdle&gt;maxPoolSize,则被重置为maxPoolSize</td></tr><tr><td>maximumPoolSize</td><td>池中最大连接数，包括闲置和使用中的连接</td><td>-1</td><td>10</td><td>如果maxPoolSize小于1，则会被重置。当minIdle&lt;=0被重置为DEFAULT_POOL_SIZE则为10;如果minIdle&gt;0则重置为minIdle的值</td></tr><tr><td>metricRegistry</td><td>该属性允许您指定一个 Codahale / Dropwizard MetricRegistry 的实例，供池使用以记录各种指标</td><td>null</td><td>null</td><td>–</td></tr><tr><td>healthCheckRegistry</td><td>该属性允许您指定池使用的Codahale / Dropwizard HealthCheckRegistry的实例来报告当前健康信息</td><td>null</td><td>null</td><td>–</td></tr><tr><td>poolName</td><td>连接池的用户定义名称，主要出现在日志记录和JMX管理控制台中以识别池和池配置</td><td>null</td><td>HikariPool-1</td><td>–</td></tr><tr><td>initializationFailTimeout</td><td>如果池无法成功初始化连接，则此属性控制池是否将 fail fast</td><td>1</td><td>1</td><td>–</td></tr><tr><td>isolateInternalQueries</td><td>是否在其自己的事务中隔离内部池查询，例如连接活动测试</td><td>FALSE</td><td>FALSE</td><td>–</td></tr><tr><td>allowPoolSuspension</td><td>控制池是否可以通过JMX暂停和恢复</td><td>FALSE</td><td>FALSE</td><td>–</td></tr><tr><td>readOnly</td><td>从池中获取的连接是否默认处于只读模式</td><td>FALSE</td><td>FALSE –</td><td></td></tr><tr><td>registerMbeans</td><td>是否注册JMX管理Bean（MBeans）</td><td>FALSE</td><td>FALSE –</td><td></td></tr><tr><td>catalog</td><td>为支持 catalog 概念的数据库设置默认 catalog driver</td><td>default</td><td>null</td><td>–</td></tr><tr><td>connectionInitSql</td><td>该属性设置一个SQL语句，在将每个新连接创建后，将其添加到池中之前执行该语句。</td><td>null</td><td>null</td><td>–</td></tr><tr><td>driverClassName</td><td>HikariCP将尝试通过仅基于jdbcUrl的DriverManager解析驱动程序，但对于一些较旧的驱动程序，还必须指定driverClassName</td><td>null</td><td>null</td><td>–</td></tr><tr><td>transactionIsolation</td><td>控制从池返回的连接的默认事务隔离级别</td><td>null</td><td>null</td><td>–</td></tr><tr><td>validationTimeout</td><td>连接将被测试活动的最大时间量</td><td>SECONDS.toMillis(5) = 5000</td><td>5000</td><td>如果小于250毫秒，则会被重置回5秒</td></tr><tr><td>leakDetectionThreshold</td><td>记录消息之前连接可能离开池的时间量，表示可能的连接泄漏</td><td>0</td><td>0</td><td>如果大于0且不是单元测试，则进一步判断：(leakDetectionThreshold &lt; SECONDS.toMillis(2) or (leakDetectionThreshold &gt; maxLifetime &amp;&amp; maxLifetime &gt; 0)，会被重置为0 . 即如果要生效则必须&gt;0，而且不能小于2秒，而且当maxLifetime &gt; 0时不能大于maxLifetime</td></tr><tr><td>dataSource</td><td>这个属性允许你直接设置数据源的实例被池包装，而不是让HikariCP通过反射来构造它</td><td>null</td><td>null</td><td>–</td></tr><tr><td>schema</td><td>该属性为支持模式概念的数据库设置默认模式 driver</td><td>default</td><td>null</td><td>–</td></tr><tr><td>threadFactory</td><td>此属性允许您设置将用于创建池使用的所有线程的java.util.concurrent.ThreadFactory的实例。</td><td>null</td><td>null</td><td>–</td></tr><tr><td>scheduledExecutor</td><td>此属性允许您设置将用于各种内部计划任务的java.util.concurrent.ScheduledExecutorService实例</td><td>null</td><td>null</td><td>–</td></tr></tbody></table><h3 id="为什么hikaricp会成为默认连接池" tabindex="-1">为什么HikariCP会成为默认连接池？ <a class="header-anchor" href="#为什么hikaricp会成为默认连接池" aria-label="Permalink to &quot;为什么HikariCP会成为默认连接池？&quot;">​</a></h3><blockquote><p>官网详细地说明了HikariCP所做的一些优化，总结如下：</p></blockquote><ul><li><strong>字节码精简</strong> ：优化代码，直到编译后的字节码最少，这样，CPU缓存可以加载更多的程序代码；</li><li><strong>优化代理和拦截器</strong>：减少代码，例如HikariCP的Statement proxy只有100行代码，只有BoneCP的十分之一；</li><li><strong>自定义数组类型（FastStatementList）代替ArrayList</strong>：避免每次get()调用都要进行range check，避免调用remove()时的从头到尾的扫描；</li><li><strong>自定义集合类型（ConcurrentBag)</strong>：提高并发读写的效率；</li><li><strong>其它</strong>：针对BoneCP缺陷的优化，比如对于耗时超过一个CPU时间片的方法调用的研究等。</li></ul><p>更多可以参考：<a href="https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole" target="_blank" rel="noreferrer">Down the Rabbit Hole在新窗口打开</a></p><h3 id="更多常见的使用问题" tabindex="-1">更多常见的使用问题 <a class="header-anchor" href="#更多常见的使用问题" aria-label="Permalink to &quot;更多常见的使用问题&quot;">​</a></h3><p>请参考 <a href="https://github.com/brettwooldridge/HikariCP/wiki/FAQ" target="_blank" rel="noreferrer">官方WIKI - FAQ在新窗口打开</a></p><h2 id="源码示例" tabindex="-1">源码示例 <a class="header-anchor" href="#源码示例" aria-label="Permalink to &quot;源码示例&quot;">​</a></h2><p><a href="https://github.com/realpdai/tech-pdai-spring-demos" target="_blank" rel="noreferrer">https://github.com/realpdai/tech-pdai-spring-demos</a></p><p>参考文章</p><p><a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noreferrer">https://github.com/brettwooldridge/HikariCP</a></p><p><a href="http://www.lanxinbase.com/?p=2482" target="_blank" rel="noreferrer">http://www.lanxinbase.com/?p=2482</a></p><p>本文转自 <a href="https://pdai.tech" target="_blank" rel="noreferrer">https://pdai.tech</a>，如有侵权，请联系删除。</p>',64)]))}const k=e(l,[["render",d]]);export{b as __pageData,k as default};
